//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../api-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './PluginsControllerClient'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type FindAllPluginsControllerQueryParameters = {
  status?: Types.Status2 | undefined ;
}

export type FindOnePluginsControllerQueryParameters = {
  id: string ;
}

export type UpdatePluginsControllerQueryParameters = {
  id: string ;
}

export type RemovePluginsControllerQueryParameters = {
  id: string ;
}

export type DeprecatePluginsControllerQueryParameters = {
  id: string ;
}

export type FindByCategoryPluginsControllerQueryParameters = {
  category: string ;
}

export type FindByExtensionPointPluginsControllerQueryParameters = {
  extensionPoint: string ;
}

export type UninstallPluginsControllerQueryParameters = {
  id: string ;
}

export type EnablePluginsControllerQueryParameters = {
  id: string ;
}

export type DisablePluginsControllerQueryParameters = {
  id: string ;
}

export type ConfigurePluginsControllerQueryParameters = {
  id: string ;
}

export type GetInstalledPluginsPluginsControllerQueryParameters = {
  organizationId: string ;
}

export type GetEnabledPluginsPluginsControllerQueryParameters = {
  organizationId: string ;
}

export type GetPaymentPluginsPluginsControllerQueryParameters = {
  organizationId: string ;
}

export type GetPluginsByTypePluginsControllerQueryParameters = {
  organizationId: string ;
  type: string ;
}

export type UploadStoragePluginsControllerMutationParameters = {
  file?: Types.FileParameter | undefined ;
  pluginId?: string | undefined ;
  version?: string | undefined ;
}

export function createUrl(): string {
  let url_ = getBaseUrl() + "/api/plugins";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createMutationKey(): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'create',
    ]);
}

/**
 * Create a new plugin
 * @return The plugin has been successfully created.
 */
export function useCreateMutation<TContext>(options?: Omit<UseMutationOptions<Types.PluginResponseDto, unknown, Types.CreatePluginDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PluginResponseDto, unknown, Types.CreatePluginDto, TContext> {
  const key = createMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CreatePluginDto) => Client.create(body),
    mutationKey: key,
  });
}
  
export function findAllUrl(status?: Types.Status2 | undefined): string {
  let url_ = getBaseUrl() + "/api/plugins?";
if (status === null)
    throw new Error("The parameter 'status' cannot be null.");
else if (status !== undefined)
    url_ += "status=" + encodeURIComponent("" + status) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let findAllDefaultOptions: Omit<UseQueryOptions<Types.PluginResponseDto[], unknown, Types.PluginResponseDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PluginResponseDto[], unknown, Types.PluginResponseDto[]>, 'queryFn'>> = {
};
export function getFindAllDefaultOptions() {
  return findAllDefaultOptions;
};
export function setFindAllDefaultOptions(options: typeof findAllDefaultOptions) {
  findAllDefaultOptions = options;
}

export function findAllQueryKey(status?: Types.Status2 | undefined): QueryKey;
export function findAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { status,  } = params[0] as FindAllPluginsControllerQueryParameters;

    return trimArrayEnd([
        'PluginsControllerClient',
        'findAll',
        status as any,
      ]);
  } else {
    return trimArrayEnd([
        'PluginsControllerClient',
        'findAll',
        ...params
      ]);
  }
}
export function __findAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.findAll(
      context.queryKey[2] as Types.Status2 | undefined,axiosConfig    );
}

export function useFindAllQuery<TSelectData = Types.PluginResponseDto[], TError = unknown>(dto: FindAllPluginsControllerQueryParameters, options?: Omit<UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get all plugins
 * @param status (optional) 
 * @return Returns all plugins.
 */
export function useFindAllQuery<TSelectData = Types.PluginResponseDto[], TError = unknown>(status?: Types.Status2 | undefined, options?: Omit<UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFindAllQuery<TSelectData = Types.PluginResponseDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let status: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ status,  } = params[0] as FindAllPluginsControllerQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [status, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PluginResponseDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __findAll(context, axiosConfig) : __findAll,
    queryKey: findAllQueryKey(status),
    ...findAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get all plugins
 * @param status (optional) 
 * @return Returns all plugins.
 */
export function setFindAllData(queryClient: QueryClient, updater: (data: Types.PluginResponseDto[] | undefined) => Types.PluginResponseDto[], status?: Types.Status2 | undefined) {
  queryClient.setQueryData(findAllQueryKey(status),
    updater
  );
}

/**
 * Get all plugins
 * @param status (optional) 
 * @return Returns all plugins.
 */
export function setFindAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PluginResponseDto[] | undefined) => Types.PluginResponseDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function registerPaymentPluginUrl(): string {
  let url_ = getBaseUrl() + "/api/plugins/payment";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function registerPaymentPluginMutationKey(): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'registerPaymentPlugin',
    ]);
}

/**
 * Register a new payment plugin
 * @return The payment plugin has been successfully registered.
 */
export function useRegisterPaymentPluginMutation<TContext>(options?: Omit<UseMutationOptions<Types.PluginResponseDto, unknown, Types.RegisterPaymentPluginDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PluginResponseDto, unknown, Types.RegisterPaymentPluginDto, TContext> {
  const key = registerPaymentPluginMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.RegisterPaymentPluginDto) => Client.registerPaymentPlugin(body),
    mutationKey: key,
  });
}
  
export function findOneUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/plugins/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let findOneDefaultOptions: Omit<UseQueryOptions<Types.PluginResponseDto, unknown, Types.PluginResponseDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PluginResponseDto, unknown, Types.PluginResponseDto>, 'queryFn'>> = {
};
export function getFindOneDefaultOptions() {
  return findOneDefaultOptions;
};
export function setFindOneDefaultOptions(options: typeof findOneDefaultOptions) {
  findOneDefaultOptions = options;
}

export function findOneQueryKey(id: string): QueryKey;
export function findOneQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as FindOnePluginsControllerQueryParameters;

    return trimArrayEnd([
        'PluginsControllerClient',
        'findOne',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'PluginsControllerClient',
        'findOne',
        ...params
      ]);
  }
}
export function __findOne(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.findOne(
      context.queryKey[2] as string,axiosConfig    );
}

export function useFindOneQuery<TSelectData = Types.PluginResponseDto, TError = unknown>(dto: FindOnePluginsControllerQueryParameters, options?: Omit<UseQueryOptions<Types.PluginResponseDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get plugin by ID
 * @return Returns the plugin if found.
 */
export function useFindOneQuery<TSelectData = Types.PluginResponseDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.PluginResponseDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFindOneQuery<TSelectData = Types.PluginResponseDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PluginResponseDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as FindOnePluginsControllerQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PluginResponseDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __findOne(context, axiosConfig) : __findOne,
    queryKey: findOneQueryKey(id),
    ...findOneDefaultOptions as unknown as Omit<UseQueryOptions<Types.PluginResponseDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get plugin by ID
 * @return Returns the plugin if found.
 */
export function setFindOneData(queryClient: QueryClient, updater: (data: Types.PluginResponseDto | undefined) => Types.PluginResponseDto, id: string) {
  queryClient.setQueryData(findOneQueryKey(id),
    updater
  );
}

/**
 * Get plugin by ID
 * @return Returns the plugin if found.
 */
export function setFindOneDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PluginResponseDto | undefined) => Types.PluginResponseDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function updateUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/plugins/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'update',
      id as any,
    ]);
}

/**
 * Update a plugin
 * @return The plugin has been successfully updated.
 */
export function useUpdateMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.PluginResponseDto, unknown, Types.UpdatePluginDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PluginResponseDto, unknown, Types.UpdatePluginDto, TContext> {
  const key = updateMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.UpdatePluginDto) => Client.update(id, body),
    mutationKey: key,
  });
}
  
type Update__MutationParameters = UpdatePluginsControllerQueryParameters & {
  body: Types.UpdatePluginDto;
}

/**
 * Update a plugin
 * @return The plugin has been successfully updated.
 */
export function useUpdateMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.PluginResponseDto, unknown, Update__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdatePluginsControllerQueryParameters}): UseMutationResult<Types.PluginResponseDto, unknown, Update__MutationParameters, TContext> {
  const key = updateMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Update__MutationParameters) => Client.update(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function removeUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/plugins/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function removeMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'remove',
      id as any,
    ]);
}

/**
 * Remove a plugin (mark as removed)
 * @return The plugin has been marked as removed.
 */
export function useRemoveMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.PluginResponseDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PluginResponseDto, unknown, void, TContext> {
  const key = removeMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.remove(id),
    mutationKey: key,
  });
}
  
type Remove__MutationParameters = RemovePluginsControllerQueryParameters

/**
 * Remove a plugin (mark as removed)
 * @return The plugin has been marked as removed.
 */
export function useRemoveMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.PluginResponseDto, unknown, Remove__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: RemovePluginsControllerQueryParameters}): UseMutationResult<Types.PluginResponseDto, unknown, Remove__MutationParameters, TContext> {
  const key = removeMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Remove__MutationParameters) => Client.remove(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function deprecateUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/plugins/{id}/deprecate";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deprecateMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'deprecate',
      id as any,
    ]);
}

/**
 * Deprecate a plugin
 * @return The plugin has been deprecated.
 */
export function useDeprecateMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.PluginResponseDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PluginResponseDto, unknown, void, TContext> {
  const key = deprecateMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.deprecate(id),
    mutationKey: key,
  });
}
  
type Deprecate__MutationParameters = DeprecatePluginsControllerQueryParameters

/**
 * Deprecate a plugin
 * @return The plugin has been deprecated.
 */
export function useDeprecateMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.PluginResponseDto, unknown, Deprecate__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeprecatePluginsControllerQueryParameters}): UseMutationResult<Types.PluginResponseDto, unknown, Deprecate__MutationParameters, TContext> {
  const key = deprecateMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Deprecate__MutationParameters) => Client.deprecate(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function findByCategoryUrl(category: string): string {
  let url_ = getBaseUrl() + "/api/plugins/category/{category}";
if (category === undefined || category === null)
  throw new Error("The parameter 'category' must be defined.");
url_ = url_.replace("{category}", encodeURIComponent("" + category));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let findByCategoryDefaultOptions: Omit<UseQueryOptions<Types.PluginResponseDto[], unknown, Types.PluginResponseDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PluginResponseDto[], unknown, Types.PluginResponseDto[]>, 'queryFn'>> = {
};
export function getFindByCategoryDefaultOptions() {
  return findByCategoryDefaultOptions;
};
export function setFindByCategoryDefaultOptions(options: typeof findByCategoryDefaultOptions) {
  findByCategoryDefaultOptions = options;
}

export function findByCategoryQueryKey(category: string): QueryKey;
export function findByCategoryQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { category,  } = params[0] as FindByCategoryPluginsControllerQueryParameters;

    return trimArrayEnd([
        'PluginsControllerClient',
        'findByCategory',
        category as any,
      ]);
  } else {
    return trimArrayEnd([
        'PluginsControllerClient',
        'findByCategory',
        ...params
      ]);
  }
}
export function __findByCategory(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.findByCategory(
      context.queryKey[2] as string,axiosConfig    );
}

export function useFindByCategoryQuery<TSelectData = Types.PluginResponseDto[], TError = unknown>(dto: FindByCategoryPluginsControllerQueryParameters, options?: Omit<UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get plugins by category
 * @return Returns all plugins in the category.
 */
export function useFindByCategoryQuery<TSelectData = Types.PluginResponseDto[], TError = unknown>(category: string, options?: Omit<UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFindByCategoryQuery<TSelectData = Types.PluginResponseDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let category: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ category,  } = params[0] as FindByCategoryPluginsControllerQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [category, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PluginResponseDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __findByCategory(context, axiosConfig) : __findByCategory,
    queryKey: findByCategoryQueryKey(category),
    ...findByCategoryDefaultOptions as unknown as Omit<UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get plugins by category
 * @return Returns all plugins in the category.
 */
export function setFindByCategoryData(queryClient: QueryClient, updater: (data: Types.PluginResponseDto[] | undefined) => Types.PluginResponseDto[], category: string) {
  queryClient.setQueryData(findByCategoryQueryKey(category),
    updater
  );
}

/**
 * Get plugins by category
 * @return Returns all plugins in the category.
 */
export function setFindByCategoryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PluginResponseDto[] | undefined) => Types.PluginResponseDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function findByExtensionPointUrl(extensionPoint: string): string {
  let url_ = getBaseUrl() + "/api/plugins/extension-point/{extensionPoint}";
if (extensionPoint === undefined || extensionPoint === null)
  throw new Error("The parameter 'extensionPoint' must be defined.");
url_ = url_.replace("{extensionPoint}", encodeURIComponent("" + extensionPoint));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let findByExtensionPointDefaultOptions: Omit<UseQueryOptions<Types.PluginResponseDto[], unknown, Types.PluginResponseDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PluginResponseDto[], unknown, Types.PluginResponseDto[]>, 'queryFn'>> = {
};
export function getFindByExtensionPointDefaultOptions() {
  return findByExtensionPointDefaultOptions;
};
export function setFindByExtensionPointDefaultOptions(options: typeof findByExtensionPointDefaultOptions) {
  findByExtensionPointDefaultOptions = options;
}

export function findByExtensionPointQueryKey(extensionPoint: string): QueryKey;
export function findByExtensionPointQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { extensionPoint,  } = params[0] as FindByExtensionPointPluginsControllerQueryParameters;

    return trimArrayEnd([
        'PluginsControllerClient',
        'findByExtensionPoint',
        extensionPoint as any,
      ]);
  } else {
    return trimArrayEnd([
        'PluginsControllerClient',
        'findByExtensionPoint',
        ...params
      ]);
  }
}
export function __findByExtensionPoint(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.findByExtensionPoint(
      context.queryKey[2] as string,axiosConfig    );
}

export function useFindByExtensionPointQuery<TSelectData = Types.PluginResponseDto[], TError = unknown>(dto: FindByExtensionPointPluginsControllerQueryParameters, options?: Omit<UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get plugins by extension point
 * @return Returns all plugins implementing the extension point.
 */
export function useFindByExtensionPointQuery<TSelectData = Types.PluginResponseDto[], TError = unknown>(extensionPoint: string, options?: Omit<UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFindByExtensionPointQuery<TSelectData = Types.PluginResponseDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let extensionPoint: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ extensionPoint,  } = params[0] as FindByExtensionPointPluginsControllerQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [extensionPoint, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.PluginResponseDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __findByExtensionPoint(context, axiosConfig) : __findByExtensionPoint,
    queryKey: findByExtensionPointQueryKey(extensionPoint),
    ...findByExtensionPointDefaultOptions as unknown as Omit<UseQueryOptions<Types.PluginResponseDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get plugins by extension point
 * @return Returns all plugins implementing the extension point.
 */
export function setFindByExtensionPointData(queryClient: QueryClient, updater: (data: Types.PluginResponseDto[] | undefined) => Types.PluginResponseDto[], extensionPoint: string) {
  queryClient.setQueryData(findByExtensionPointQueryKey(extensionPoint),
    updater
  );
}

/**
 * Get plugins by extension point
 * @return Returns all plugins implementing the extension point.
 */
export function setFindByExtensionPointDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PluginResponseDto[] | undefined) => Types.PluginResponseDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function installUrl(): string {
  let url_ = getBaseUrl() + "/api/plugins/install";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function installMutationKey(): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'install',
    ]);
}

/**
 * Install a plugin for an organization
 * @return The plugin has been successfully installed.
 */
export function useInstallMutation<TContext>(options?: Omit<UseMutationOptions<Types.InstalledPluginDto, unknown, Types.SimpleInstallPluginDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.InstalledPluginDto, unknown, Types.SimpleInstallPluginDto, TContext> {
  const key = installMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.SimpleInstallPluginDto) => Client.install(body),
    mutationKey: key,
  });
}
  
export function uninstallUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/plugins/installed/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function uninstallMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'uninstall',
      id as any,
    ]);
}

/**
 * Uninstall a plugin from an organization
 * @return The plugin has been successfully uninstalled.
 */
export function useUninstallMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = uninstallMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.uninstall(id),
    mutationKey: key,
  });
}
  
type Uninstall__MutationParameters = UninstallPluginsControllerQueryParameters

/**
 * Uninstall a plugin from an organization
 * @return The plugin has been successfully uninstalled.
 */
export function useUninstallMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, Uninstall__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UninstallPluginsControllerQueryParameters}): UseMutationResult<void, unknown, Uninstall__MutationParameters, TContext> {
  const key = uninstallMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Uninstall__MutationParameters) => Client.uninstall(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function enableUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/plugins/installed/{id}/enable";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function enableMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'enable',
      id as any,
    ]);
}

/**
 * Enable an installed plugin
 * @return The plugin has been enabled.
 */
export function useEnableMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.InstalledPluginDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.InstalledPluginDto, unknown, void, TContext> {
  const key = enableMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.enable(id),
    mutationKey: key,
  });
}
  
type Enable__MutationParameters = EnablePluginsControllerQueryParameters

/**
 * Enable an installed plugin
 * @return The plugin has been enabled.
 */
export function useEnableMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.InstalledPluginDto, unknown, Enable__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: EnablePluginsControllerQueryParameters}): UseMutationResult<Types.InstalledPluginDto, unknown, Enable__MutationParameters, TContext> {
  const key = enableMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Enable__MutationParameters) => Client.enable(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function disableUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/plugins/installed/{id}/disable";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function disableMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'disable',
      id as any,
    ]);
}

/**
 * Disable an installed plugin
 * @return The plugin has been disabled.
 */
export function useDisableMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.InstalledPluginDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.InstalledPluginDto, unknown, void, TContext> {
  const key = disableMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.disable(id),
    mutationKey: key,
  });
}
  
type Disable__MutationParameters = DisablePluginsControllerQueryParameters

/**
 * Disable an installed plugin
 * @return The plugin has been disabled.
 */
export function useDisableMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.InstalledPluginDto, unknown, Disable__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DisablePluginsControllerQueryParameters}): UseMutationResult<Types.InstalledPluginDto, unknown, Disable__MutationParameters, TContext> {
  const key = disableMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Disable__MutationParameters) => Client.disable(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function configureUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/plugins/installed/{id}/configure";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function configureMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'configure',
      id as any,
    ]);
}

/**
 * Update plugin configuration
 * @return The plugin configuration has been updated.
 */
export function useConfigureMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.InstalledPluginDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.InstalledPluginDto, unknown, void, TContext> {
  const key = configureMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.configure(id),
    mutationKey: key,
  });
}
  
type Configure__MutationParameters = ConfigurePluginsControllerQueryParameters

/**
 * Update plugin configuration
 * @return The plugin configuration has been updated.
 */
export function useConfigureMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.InstalledPluginDto, unknown, Configure__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ConfigurePluginsControllerQueryParameters}): UseMutationResult<Types.InstalledPluginDto, unknown, Configure__MutationParameters, TContext> {
  const key = configureMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: Configure__MutationParameters) => Client.configure(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function getInstalledPluginsUrl(organizationId: string): string {
  let url_ = getBaseUrl() + "/api/plugins/organization/{organizationId}";
if (organizationId === undefined || organizationId === null)
  throw new Error("The parameter 'organizationId' must be defined.");
url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getInstalledPluginsDefaultOptions: Omit<UseQueryOptions<Types.InstalledPluginDto[], unknown, Types.InstalledPluginDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.InstalledPluginDto[], unknown, Types.InstalledPluginDto[]>, 'queryFn'>> = {
};
export function getGetInstalledPluginsDefaultOptions() {
  return getInstalledPluginsDefaultOptions;
};
export function setGetInstalledPluginsDefaultOptions(options: typeof getInstalledPluginsDefaultOptions) {
  getInstalledPluginsDefaultOptions = options;
}

export function getInstalledPluginsQueryKey(organizationId: string): QueryKey;
export function getInstalledPluginsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { organizationId,  } = params[0] as GetInstalledPluginsPluginsControllerQueryParameters;

    return trimArrayEnd([
        'PluginsControllerClient',
        'getInstalledPlugins',
        organizationId as any,
      ]);
  } else {
    return trimArrayEnd([
        'PluginsControllerClient',
        'getInstalledPlugins',
        ...params
      ]);
  }
}
export function __getInstalledPlugins(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getInstalledPlugins(
      context.queryKey[2] as string,axiosConfig    );
}

export function useGetInstalledPluginsQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(dto: GetInstalledPluginsPluginsControllerQueryParameters, options?: Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get all installed plugins for an organization
 * @return Returns all installed plugins for the organization.
 */
export function useGetInstalledPluginsQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(organizationId: string, options?: Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetInstalledPluginsQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let organizationId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ organizationId,  } = params[0] as GetInstalledPluginsPluginsControllerQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [organizationId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.InstalledPluginDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getInstalledPlugins(context, axiosConfig) : __getInstalledPlugins,
    queryKey: getInstalledPluginsQueryKey(organizationId),
    ...getInstalledPluginsDefaultOptions as unknown as Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get all installed plugins for an organization
 * @return Returns all installed plugins for the organization.
 */
export function setGetInstalledPluginsData(queryClient: QueryClient, updater: (data: Types.InstalledPluginDto[] | undefined) => Types.InstalledPluginDto[], organizationId: string) {
  queryClient.setQueryData(getInstalledPluginsQueryKey(organizationId),
    updater
  );
}

/**
 * Get all installed plugins for an organization
 * @return Returns all installed plugins for the organization.
 */
export function setGetInstalledPluginsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.InstalledPluginDto[] | undefined) => Types.InstalledPluginDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getEnabledPluginsUrl(organizationId: string): string {
  let url_ = getBaseUrl() + "/api/plugins/organization/{organizationId}/enabled";
if (organizationId === undefined || organizationId === null)
  throw new Error("The parameter 'organizationId' must be defined.");
url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getEnabledPluginsDefaultOptions: Omit<UseQueryOptions<Types.InstalledPluginDto[], unknown, Types.InstalledPluginDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.InstalledPluginDto[], unknown, Types.InstalledPluginDto[]>, 'queryFn'>> = {
};
export function getGetEnabledPluginsDefaultOptions() {
  return getEnabledPluginsDefaultOptions;
};
export function setGetEnabledPluginsDefaultOptions(options: typeof getEnabledPluginsDefaultOptions) {
  getEnabledPluginsDefaultOptions = options;
}

export function getEnabledPluginsQueryKey(organizationId: string): QueryKey;
export function getEnabledPluginsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { organizationId,  } = params[0] as GetEnabledPluginsPluginsControllerQueryParameters;

    return trimArrayEnd([
        'PluginsControllerClient',
        'getEnabledPlugins',
        organizationId as any,
      ]);
  } else {
    return trimArrayEnd([
        'PluginsControllerClient',
        'getEnabledPlugins',
        ...params
      ]);
  }
}
export function __getEnabledPlugins(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getEnabledPlugins(
      context.queryKey[2] as string,axiosConfig    );
}

export function useGetEnabledPluginsQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(dto: GetEnabledPluginsPluginsControllerQueryParameters, options?: Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get all enabled plugins for an organization
 * @return Returns all enabled plugins for the organization.
 */
export function useGetEnabledPluginsQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(organizationId: string, options?: Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetEnabledPluginsQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let organizationId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ organizationId,  } = params[0] as GetEnabledPluginsPluginsControllerQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [organizationId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.InstalledPluginDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getEnabledPlugins(context, axiosConfig) : __getEnabledPlugins,
    queryKey: getEnabledPluginsQueryKey(organizationId),
    ...getEnabledPluginsDefaultOptions as unknown as Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get all enabled plugins for an organization
 * @return Returns all enabled plugins for the organization.
 */
export function setGetEnabledPluginsData(queryClient: QueryClient, updater: (data: Types.InstalledPluginDto[] | undefined) => Types.InstalledPluginDto[], organizationId: string) {
  queryClient.setQueryData(getEnabledPluginsQueryKey(organizationId),
    updater
  );
}

/**
 * Get all enabled plugins for an organization
 * @return Returns all enabled plugins for the organization.
 */
export function setGetEnabledPluginsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.InstalledPluginDto[] | undefined) => Types.InstalledPluginDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getPaymentPluginsUrl(organizationId: string): string {
  let url_ = getBaseUrl() + "/api/plugins/organization/{organizationId}/payment";
if (organizationId === undefined || organizationId === null)
  throw new Error("The parameter 'organizationId' must be defined.");
url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getPaymentPluginsDefaultOptions: Omit<UseQueryOptions<Types.InstalledPluginDto[], unknown, Types.InstalledPluginDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.InstalledPluginDto[], unknown, Types.InstalledPluginDto[]>, 'queryFn'>> = {
};
export function getGetPaymentPluginsDefaultOptions() {
  return getPaymentPluginsDefaultOptions;
};
export function setGetPaymentPluginsDefaultOptions(options: typeof getPaymentPluginsDefaultOptions) {
  getPaymentPluginsDefaultOptions = options;
}

export function getPaymentPluginsQueryKey(organizationId: string): QueryKey;
export function getPaymentPluginsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { organizationId,  } = params[0] as GetPaymentPluginsPluginsControllerQueryParameters;

    return trimArrayEnd([
        'PluginsControllerClient',
        'getPaymentPlugins',
        organizationId as any,
      ]);
  } else {
    return trimArrayEnd([
        'PluginsControllerClient',
        'getPaymentPlugins',
        ...params
      ]);
  }
}
export function __getPaymentPlugins(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getPaymentPlugins(
      context.queryKey[2] as string,axiosConfig    );
}

export function useGetPaymentPluginsQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(dto: GetPaymentPluginsPluginsControllerQueryParameters, options?: Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get payment plugins for an organization
 * @return Returns all enabled payment plugins for the organization.
 */
export function useGetPaymentPluginsQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(organizationId: string, options?: Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetPaymentPluginsQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let organizationId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ organizationId,  } = params[0] as GetPaymentPluginsPluginsControllerQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [organizationId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.InstalledPluginDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getPaymentPlugins(context, axiosConfig) : __getPaymentPlugins,
    queryKey: getPaymentPluginsQueryKey(organizationId),
    ...getPaymentPluginsDefaultOptions as unknown as Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get payment plugins for an organization
 * @return Returns all enabled payment plugins for the organization.
 */
export function setGetPaymentPluginsData(queryClient: QueryClient, updater: (data: Types.InstalledPluginDto[] | undefined) => Types.InstalledPluginDto[], organizationId: string) {
  queryClient.setQueryData(getPaymentPluginsQueryKey(organizationId),
    updater
  );
}

/**
 * Get payment plugins for an organization
 * @return Returns all enabled payment plugins for the organization.
 */
export function setGetPaymentPluginsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.InstalledPluginDto[] | undefined) => Types.InstalledPluginDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getPluginsByTypeUrl(organizationId: string, type: string): string {
  let url_ = getBaseUrl() + "/api/plugins/organization/{organizationId}/type/{type}";
if (organizationId === undefined || organizationId === null)
  throw new Error("The parameter 'organizationId' must be defined.");
url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
if (type === undefined || type === null)
  throw new Error("The parameter 'type' must be defined.");
url_ = url_.replace("{type}", encodeURIComponent("" + type));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getPluginsByTypeDefaultOptions: Omit<UseQueryOptions<Types.InstalledPluginDto[], unknown, Types.InstalledPluginDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.InstalledPluginDto[], unknown, Types.InstalledPluginDto[]>, 'queryFn'>> = {
};
export function getGetPluginsByTypeDefaultOptions() {
  return getPluginsByTypeDefaultOptions;
};
export function setGetPluginsByTypeDefaultOptions(options: typeof getPluginsByTypeDefaultOptions) {
  getPluginsByTypeDefaultOptions = options;
}

export function getPluginsByTypeQueryKey(dto: GetPluginsByTypePluginsControllerQueryParameters): QueryKey;
export function getPluginsByTypeQueryKey(organizationId: string, type: string): QueryKey;
export function getPluginsByTypeQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { organizationId, type,  } = params[0] as GetPluginsByTypePluginsControllerQueryParameters;

    return trimArrayEnd([
        'PluginsControllerClient',
        'getPluginsByType',
        organizationId as any,
        type as any,
      ]);
  } else {
    return trimArrayEnd([
        'PluginsControllerClient',
        'getPluginsByType',
        ...params
      ]);
  }
}
export function __getPluginsByType(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getPluginsByType(
      context.queryKey[2] as string,       context.queryKey[3] as string,axiosConfig    );
}

export function useGetPluginsByTypeQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(dto: GetPluginsByTypePluginsControllerQueryParameters, options?: Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get plugins by type for an organization
 * @return Returns all plugins of the specified type for the organization.
 */
export function useGetPluginsByTypeQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(organizationId: string, type: string, options?: Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetPluginsByTypeQuery<TSelectData = Types.InstalledPluginDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let organizationId: any = undefined;
  let type: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ organizationId, type,  } = params[0] as GetPluginsByTypePluginsControllerQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [organizationId, type, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.InstalledPluginDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getPluginsByType(context, axiosConfig) : __getPluginsByType,
    queryKey: getPluginsByTypeQueryKey(organizationId, type),
    ...getPluginsByTypeDefaultOptions as unknown as Omit<UseQueryOptions<Types.InstalledPluginDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get plugins by type for an organization
 * @return Returns all plugins of the specified type for the organization.
 */
export function setGetPluginsByTypeData(queryClient: QueryClient, updater: (data: Types.InstalledPluginDto[] | undefined) => Types.InstalledPluginDto[], organizationId: string, type: string) {
  queryClient.setQueryData(getPluginsByTypeQueryKey(organizationId, type),
    updater
  );
}

/**
 * Get plugins by type for an organization
 * @return Returns all plugins of the specified type for the organization.
 */
export function setGetPluginsByTypeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.InstalledPluginDto[] | undefined) => Types.InstalledPluginDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function uploadStorageUrl(): string {
  let url_ = getBaseUrl() + "/api/plugins/storage/upload";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function uploadStorageMutationKey(): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'uploadStorage',
    ]);
}

/**
 * Upload plugin bundle to storage server
 * @param file (optional) Plugin bundle file (JavaScript)
 * @param pluginId (optional) Plugin ID for storage path
 * @param version (optional) Plugin version for storage path
 * @return Plugin bundle successfully uploaded to storage
 */
export function useUploadStorageMutation<TContext>(options?: Omit<UseMutationOptions<Types.Anonymous2, unknown, UploadStoragePluginsControllerMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Anonymous2, unknown, UploadStoragePluginsControllerMutationParameters, TContext> {
  const key = uploadStorageMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (uploadStoragePluginsControllerMutationParameters: UploadStoragePluginsControllerMutationParameters) => Client.uploadStorage(uploadStoragePluginsControllerMutationParameters.file, uploadStoragePluginsControllerMutationParameters.pluginId, uploadStoragePluginsControllerMutationParameters.version),
    mutationKey: key,
  });
}
  
export function createMetadataUrl(): string {
  let url_ = getBaseUrl() + "/api/plugins/metadata/create";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createMetadataMutationKey(): MutationKey {
  return trimArrayEnd([
      'PluginsControllerClient',
      'createMetadata',
    ]);
}

/**
 * Create plugin metadata entry in MongoDB
 * @return Plugin metadata successfully created
 */
export function useCreateMetadataMutation<TContext>(options?: Omit<UseMutationOptions<Types.PluginResponseDto, unknown, Types.Body, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PluginResponseDto, unknown, Types.Body, TContext> {
  const key = createMetadataMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.Body) => Client.createMetadata(body),
    mutationKey: key,
  });
}