//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../api-client';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../api-client';
import { getAxios, getBaseUrl } from './helpers';

/**
 * Create a new plugin
 * @return The plugin has been successfully created.
 */
export function create(body: Types.CreatePluginDto, config?: AxiosRequestConfig | undefined): Promise<Types.PluginResponseDto> {
    let url_ = getBaseUrl() + "/api/plugins";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreate,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigCreate?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreate(_response);
    });
}

function processCreate(response: AxiosResponse): Promise<Types.PluginResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 201) {
        const _responseText = response.data;
        let result201: any = null;
        let resultData201  = _responseText;
        result201 = Types.PluginResponseDto.fromJS(resultData201);
        return Promise.resolve<Types.PluginResponseDto>(result201);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PluginResponseDto>(null as any);
}

/**
 * Get all plugins
 * @param status (optional) 
 * @return Returns all plugins.
 */
export function findAll(status?: Types.Status2 | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PluginResponseDto[]> {
    let url_ = getBaseUrl() + "/api/plugins?";
    if (status === null)
        throw new Error("The parameter 'status' cannot be null.");
    else if (status !== undefined)
        url_ += "status=" + encodeURIComponent("" + status) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFindAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigFindAll?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFindAll(_response);
    });
}

function processFindAll(response: AxiosResponse): Promise<Types.PluginResponseDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.PluginResponseDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.PluginResponseDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PluginResponseDto[]>(null as any);
}

/**
 * Register a new payment plugin
 * @return The payment plugin has been successfully registered.
 */
export function registerPaymentPlugin(body: Types.RegisterPaymentPluginDto, config?: AxiosRequestConfig | undefined): Promise<Types.PluginResponseDto> {
    let url_ = getBaseUrl() + "/api/plugins/payment";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRegisterPaymentPlugin,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigRegisterPaymentPlugin?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRegisterPaymentPlugin(_response);
    });
}

function processRegisterPaymentPlugin(response: AxiosResponse): Promise<Types.PluginResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 201) {
        const _responseText = response.data;
        let result201: any = null;
        let resultData201  = _responseText;
        result201 = Types.PluginResponseDto.fromJS(resultData201);
        return Promise.resolve<Types.PluginResponseDto>(result201);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PluginResponseDto>(null as any);
}

/**
 * Get plugin by ID
 * @return Returns the plugin if found.
 */
export function findOne(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.PluginResponseDto> {
    let url_ = getBaseUrl() + "/api/plugins/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFindOne,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigFindOne?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFindOne(_response);
    });
}

function processFindOne(response: AxiosResponse): Promise<Types.PluginResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.PluginResponseDto.fromJS(resultData200);
        return Promise.resolve<Types.PluginResponseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PluginResponseDto>(null as any);
}

/**
 * Update a plugin
 * @return The plugin has been successfully updated.
 */
export function update(id: string, body: Types.UpdatePluginDto, config?: AxiosRequestConfig | undefined): Promise<Types.PluginResponseDto> {
    let url_ = getBaseUrl() + "/api/plugins/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUpdate,
        ...config,
        data: content_,
        method: "PATCH",
        url: url_,
        headers: {
            ..._requestConfigUpdate?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUpdate(_response);
    });
}

function processUpdate(response: AxiosResponse): Promise<Types.PluginResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.PluginResponseDto.fromJS(resultData200);
        return Promise.resolve<Types.PluginResponseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PluginResponseDto>(null as any);
}

/**
 * Remove a plugin (mark as removed)
 * @return The plugin has been marked as removed.
 */
export function remove(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.PluginResponseDto> {
    let url_ = getBaseUrl() + "/api/plugins/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigRemove,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigRemove?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRemove(_response);
    });
}

function processRemove(response: AxiosResponse): Promise<Types.PluginResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.PluginResponseDto.fromJS(resultData200);
        return Promise.resolve<Types.PluginResponseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PluginResponseDto>(null as any);
}

/**
 * Deprecate a plugin
 * @return The plugin has been deprecated.
 */
export function deprecate(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.PluginResponseDto> {
    let url_ = getBaseUrl() + "/api/plugins/{id}/deprecate";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDeprecate,
        ...config,
        method: "PATCH",
        url: url_,
        headers: {
            ..._requestConfigDeprecate?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDeprecate(_response);
    });
}

function processDeprecate(response: AxiosResponse): Promise<Types.PluginResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.PluginResponseDto.fromJS(resultData200);
        return Promise.resolve<Types.PluginResponseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PluginResponseDto>(null as any);
}

/**
 * Get plugins by category
 * @return Returns all plugins in the category.
 */
export function findByCategory(category: string, config?: AxiosRequestConfig | undefined): Promise<Types.PluginResponseDto[]> {
    let url_ = getBaseUrl() + "/api/plugins/category/{category}";
    if (category === undefined || category === null)
      throw new Error("The parameter 'category' must be defined.");
    url_ = url_.replace("{category}", encodeURIComponent("" + category));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFindByCategory,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigFindByCategory?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFindByCategory(_response);
    });
}

function processFindByCategory(response: AxiosResponse): Promise<Types.PluginResponseDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.PluginResponseDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.PluginResponseDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PluginResponseDto[]>(null as any);
}

/**
 * Get plugins by extension point
 * @return Returns all plugins implementing the extension point.
 */
export function findByExtensionPoint(extensionPoint: string, config?: AxiosRequestConfig | undefined): Promise<Types.PluginResponseDto[]> {
    let url_ = getBaseUrl() + "/api/plugins/extension-point/{extensionPoint}";
    if (extensionPoint === undefined || extensionPoint === null)
      throw new Error("The parameter 'extensionPoint' must be defined.");
    url_ = url_.replace("{extensionPoint}", encodeURIComponent("" + extensionPoint));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFindByExtensionPoint,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigFindByExtensionPoint?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFindByExtensionPoint(_response);
    });
}

function processFindByExtensionPoint(response: AxiosResponse): Promise<Types.PluginResponseDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.PluginResponseDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.PluginResponseDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PluginResponseDto[]>(null as any);
}

/**
 * Install a plugin for an organization
 * @return The plugin has been successfully installed.
 */
export function install(body: Types.SimpleInstallPluginDto, config?: AxiosRequestConfig | undefined): Promise<Types.InstalledPluginDto> {
    let url_ = getBaseUrl() + "/api/plugins/install";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigInstall,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigInstall?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processInstall(_response);
    });
}

function processInstall(response: AxiosResponse): Promise<Types.InstalledPluginDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 201) {
        const _responseText = response.data;
        let result201: any = null;
        let resultData201  = _responseText;
        result201 = Types.InstalledPluginDto.fromJS(resultData201);
        return Promise.resolve<Types.InstalledPluginDto>(result201);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.InstalledPluginDto>(null as any);
}

/**
 * Uninstall a plugin from an organization
 * @return The plugin has been successfully uninstalled.
 */
export function uninstall(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/plugins/installed/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUninstall,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigUninstall?.headers,
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUninstall(_response);
    });
}

function processUninstall(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * Enable an installed plugin
 * @return The plugin has been enabled.
 */
export function enable(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.InstalledPluginDto> {
    let url_ = getBaseUrl() + "/api/plugins/installed/{id}/enable";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigEnable,
        ...config,
        method: "PATCH",
        url: url_,
        headers: {
            ..._requestConfigEnable?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processEnable(_response);
    });
}

function processEnable(response: AxiosResponse): Promise<Types.InstalledPluginDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.InstalledPluginDto.fromJS(resultData200);
        return Promise.resolve<Types.InstalledPluginDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.InstalledPluginDto>(null as any);
}

/**
 * Disable an installed plugin
 * @return The plugin has been disabled.
 */
export function disable(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.InstalledPluginDto> {
    let url_ = getBaseUrl() + "/api/plugins/installed/{id}/disable";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDisable,
        ...config,
        method: "PATCH",
        url: url_,
        headers: {
            ..._requestConfigDisable?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDisable(_response);
    });
}

function processDisable(response: AxiosResponse): Promise<Types.InstalledPluginDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.InstalledPluginDto.fromJS(resultData200);
        return Promise.resolve<Types.InstalledPluginDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.InstalledPluginDto>(null as any);
}

/**
 * Update plugin configuration
 * @return The plugin configuration has been updated.
 */
export function configure(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.InstalledPluginDto> {
    let url_ = getBaseUrl() + "/api/plugins/installed/{id}/configure";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigConfigure,
        ...config,
        method: "PATCH",
        url: url_,
        headers: {
            ..._requestConfigConfigure?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConfigure(_response);
    });
}

function processConfigure(response: AxiosResponse): Promise<Types.InstalledPluginDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.InstalledPluginDto.fromJS(resultData200);
        return Promise.resolve<Types.InstalledPluginDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.InstalledPluginDto>(null as any);
}

/**
 * Get all installed plugins for an organization
 * @return Returns all installed plugins for the organization.
 */
export function getInstalledPlugins(organizationId: string, config?: AxiosRequestConfig | undefined): Promise<Types.InstalledPluginDto[]> {
    let url_ = getBaseUrl() + "/api/plugins/organization/{organizationId}";
    if (organizationId === undefined || organizationId === null)
      throw new Error("The parameter 'organizationId' must be defined.");
    url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetInstalledPlugins,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetInstalledPlugins?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetInstalledPlugins(_response);
    });
}

function processGetInstalledPlugins(response: AxiosResponse): Promise<Types.InstalledPluginDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.InstalledPluginDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.InstalledPluginDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.InstalledPluginDto[]>(null as any);
}

/**
 * Get all enabled plugins for an organization
 * @return Returns all enabled plugins for the organization.
 */
export function getEnabledPlugins(organizationId: string, config?: AxiosRequestConfig | undefined): Promise<Types.InstalledPluginDto[]> {
    let url_ = getBaseUrl() + "/api/plugins/organization/{organizationId}/enabled";
    if (organizationId === undefined || organizationId === null)
      throw new Error("The parameter 'organizationId' must be defined.");
    url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetEnabledPlugins,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetEnabledPlugins?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetEnabledPlugins(_response);
    });
}

function processGetEnabledPlugins(response: AxiosResponse): Promise<Types.InstalledPluginDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.InstalledPluginDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.InstalledPluginDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.InstalledPluginDto[]>(null as any);
}

/**
 * Get payment plugins for an organization
 * @return Returns all enabled payment plugins for the organization.
 */
export function getPaymentPlugins(organizationId: string, config?: AxiosRequestConfig | undefined): Promise<Types.InstalledPluginDto[]> {
    let url_ = getBaseUrl() + "/api/plugins/organization/{organizationId}/payment";
    if (organizationId === undefined || organizationId === null)
      throw new Error("The parameter 'organizationId' must be defined.");
    url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetPaymentPlugins,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetPaymentPlugins?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetPaymentPlugins(_response);
    });
}

function processGetPaymentPlugins(response: AxiosResponse): Promise<Types.InstalledPluginDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.InstalledPluginDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.InstalledPluginDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.InstalledPluginDto[]>(null as any);
}

/**
 * Get plugins by type for an organization
 * @return Returns all plugins of the specified type for the organization.
 */
export function getPluginsByType(organizationId: string, type: string, config?: AxiosRequestConfig | undefined): Promise<Types.InstalledPluginDto[]> {
    let url_ = getBaseUrl() + "/api/plugins/organization/{organizationId}/type/{type}";
    if (organizationId === undefined || organizationId === null)
      throw new Error("The parameter 'organizationId' must be defined.");
    url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetPluginsByType,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetPluginsByType?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetPluginsByType(_response);
    });
}

function processGetPluginsByType(response: AxiosResponse): Promise<Types.InstalledPluginDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.InstalledPluginDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.InstalledPluginDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.InstalledPluginDto[]>(null as any);
}

/**
 * Upload plugin bundle to storage server
 * @param file (optional) Plugin bundle file (JavaScript)
 * @param pluginId (optional) Plugin ID for storage path
 * @param version (optional) Plugin version for storage path
 * @return Plugin bundle successfully uploaded to storage
 */
export function uploadStorage(file?: Types.FileParameter | undefined, pluginId?: string | undefined, version?: string | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.Anonymous2> {
    let url_ = getBaseUrl() + "/api/plugins/storage/upload";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file === null || file === undefined)
        throw new Error("The parameter 'file' cannot be null.");
    else
        content_.append("file", file.data, file.fileName ? file.fileName : "file");
    if (pluginId === null || pluginId === undefined)
        throw new Error("The parameter 'pluginId' cannot be null.");
    else
        content_.append("pluginId", pluginId.toString());
    if (version === null || version === undefined)
        throw new Error("The parameter 'version' cannot be null.");
    else
        content_.append("version", version.toString());

    let options_: AxiosRequestConfig = {
        ..._requestConfigUploadStorage,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigUploadStorage?.headers,
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUploadStorage(_response);
    });
}

function processUploadStorage(response: AxiosResponse): Promise<Types.Anonymous2> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 201) {
        const _responseText = response.data;
        let result201: any = null;
        let resultData201  = _responseText;
        result201 = Types.Anonymous2.fromJS(resultData201);
        return Promise.resolve<Types.Anonymous2>(result201);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Anonymous2>(null as any);
}

/**
 * Create plugin metadata entry in MongoDB
 * @return Plugin metadata successfully created
 */
export function createMetadata(body: Types.Body, config?: AxiosRequestConfig | undefined): Promise<Types.PluginResponseDto> {
    let url_ = getBaseUrl() + "/api/plugins/metadata/create";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreateMetadata,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigCreateMetadata?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json",
            ...config?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreateMetadata(_response);
    });
}

function processCreateMetadata(response: AxiosResponse): Promise<Types.PluginResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 201) {
        const _responseText = response.data;
        let result201: any = null;
        let resultData201  = _responseText;
        result201 = Types.PluginResponseDto.fromJS(resultData201);
        return Promise.resolve<Types.PluginResponseDto>(result201);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PluginResponseDto>(null as any);
}
let _requestConfigCreate: Partial<AxiosRequestConfig> | null;
export function getCreateRequestConfig() {
  return _requestConfigCreate;
}
export function setCreateRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreate = value;
}
export function patchCreateRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreate = patch(_requestConfigCreate ?? {});
}

let _requestConfigFindAll: Partial<AxiosRequestConfig> | null;
export function getFindAllRequestConfig() {
  return _requestConfigFindAll;
}
export function setFindAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFindAll = value;
}
export function patchFindAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFindAll = patch(_requestConfigFindAll ?? {});
}

let _requestConfigRegisterPaymentPlugin: Partial<AxiosRequestConfig> | null;
export function getRegisterPaymentPluginRequestConfig() {
  return _requestConfigRegisterPaymentPlugin;
}
export function setRegisterPaymentPluginRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRegisterPaymentPlugin = value;
}
export function patchRegisterPaymentPluginRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRegisterPaymentPlugin = patch(_requestConfigRegisterPaymentPlugin ?? {});
}

let _requestConfigFindOne: Partial<AxiosRequestConfig> | null;
export function getFindOneRequestConfig() {
  return _requestConfigFindOne;
}
export function setFindOneRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFindOne = value;
}
export function patchFindOneRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFindOne = patch(_requestConfigFindOne ?? {});
}

let _requestConfigUpdate: Partial<AxiosRequestConfig> | null;
export function getUpdateRequestConfig() {
  return _requestConfigUpdate;
}
export function setUpdateRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUpdate = value;
}
export function patchUpdateRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUpdate = patch(_requestConfigUpdate ?? {});
}

let _requestConfigRemove: Partial<AxiosRequestConfig> | null;
export function getRemoveRequestConfig() {
  return _requestConfigRemove;
}
export function setRemoveRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRemove = value;
}
export function patchRemoveRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRemove = patch(_requestConfigRemove ?? {});
}

let _requestConfigDeprecate: Partial<AxiosRequestConfig> | null;
export function getDeprecateRequestConfig() {
  return _requestConfigDeprecate;
}
export function setDeprecateRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDeprecate = value;
}
export function patchDeprecateRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDeprecate = patch(_requestConfigDeprecate ?? {});
}

let _requestConfigFindByCategory: Partial<AxiosRequestConfig> | null;
export function getFindByCategoryRequestConfig() {
  return _requestConfigFindByCategory;
}
export function setFindByCategoryRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFindByCategory = value;
}
export function patchFindByCategoryRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFindByCategory = patch(_requestConfigFindByCategory ?? {});
}

let _requestConfigFindByExtensionPoint: Partial<AxiosRequestConfig> | null;
export function getFindByExtensionPointRequestConfig() {
  return _requestConfigFindByExtensionPoint;
}
export function setFindByExtensionPointRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFindByExtensionPoint = value;
}
export function patchFindByExtensionPointRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFindByExtensionPoint = patch(_requestConfigFindByExtensionPoint ?? {});
}

let _requestConfigInstall: Partial<AxiosRequestConfig> | null;
export function getInstallRequestConfig() {
  return _requestConfigInstall;
}
export function setInstallRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigInstall = value;
}
export function patchInstallRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigInstall = patch(_requestConfigInstall ?? {});
}

let _requestConfigUninstall: Partial<AxiosRequestConfig> | null;
export function getUninstallRequestConfig() {
  return _requestConfigUninstall;
}
export function setUninstallRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUninstall = value;
}
export function patchUninstallRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUninstall = patch(_requestConfigUninstall ?? {});
}

let _requestConfigEnable: Partial<AxiosRequestConfig> | null;
export function getEnableRequestConfig() {
  return _requestConfigEnable;
}
export function setEnableRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigEnable = value;
}
export function patchEnableRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigEnable = patch(_requestConfigEnable ?? {});
}

let _requestConfigDisable: Partial<AxiosRequestConfig> | null;
export function getDisableRequestConfig() {
  return _requestConfigDisable;
}
export function setDisableRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDisable = value;
}
export function patchDisableRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDisable = patch(_requestConfigDisable ?? {});
}

let _requestConfigConfigure: Partial<AxiosRequestConfig> | null;
export function getConfigureRequestConfig() {
  return _requestConfigConfigure;
}
export function setConfigureRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConfigure = value;
}
export function patchConfigureRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConfigure = patch(_requestConfigConfigure ?? {});
}

let _requestConfigGetInstalledPlugins: Partial<AxiosRequestConfig> | null;
export function getGetInstalledPluginsRequestConfig() {
  return _requestConfigGetInstalledPlugins;
}
export function setGetInstalledPluginsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetInstalledPlugins = value;
}
export function patchGetInstalledPluginsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetInstalledPlugins = patch(_requestConfigGetInstalledPlugins ?? {});
}

let _requestConfigGetEnabledPlugins: Partial<AxiosRequestConfig> | null;
export function getGetEnabledPluginsRequestConfig() {
  return _requestConfigGetEnabledPlugins;
}
export function setGetEnabledPluginsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetEnabledPlugins = value;
}
export function patchGetEnabledPluginsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetEnabledPlugins = patch(_requestConfigGetEnabledPlugins ?? {});
}

let _requestConfigGetPaymentPlugins: Partial<AxiosRequestConfig> | null;
export function getGetPaymentPluginsRequestConfig() {
  return _requestConfigGetPaymentPlugins;
}
export function setGetPaymentPluginsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetPaymentPlugins = value;
}
export function patchGetPaymentPluginsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetPaymentPlugins = patch(_requestConfigGetPaymentPlugins ?? {});
}

let _requestConfigGetPluginsByType: Partial<AxiosRequestConfig> | null;
export function getGetPluginsByTypeRequestConfig() {
  return _requestConfigGetPluginsByType;
}
export function setGetPluginsByTypeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetPluginsByType = value;
}
export function patchGetPluginsByTypeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetPluginsByType = patch(_requestConfigGetPluginsByType ?? {});
}

let _requestConfigUploadStorage: Partial<AxiosRequestConfig> | null;
export function getUploadStorageRequestConfig() {
  return _requestConfigUploadStorage;
}
export function setUploadStorageRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUploadStorage = value;
}
export function patchUploadStorageRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUploadStorage = patch(_requestConfigUploadStorage ?? {});
}

let _requestConfigCreateMetadata: Partial<AxiosRequestConfig> | null;
export function getCreateMetadataRequestConfig() {
  return _requestConfigCreateMetadata;
}
export function setCreateMetadataRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreateMetadata = value;
}
export function patchCreateMetadataRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreateMetadata = patch(_requestConfigCreateMetadata ?? {});
}