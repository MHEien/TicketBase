//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../api-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './PaymentsControllerClient'
export { Client };
import type { AxiosRequestConfig } from 'axios';



export type GetTransactionsByOrderPaymentsControllerQueryParameters = {
  orderId: string ;
}

export type GetTransactionsByOrganizationPaymentsControllerQueryParameters = {
  organizationId: string ;
  fromDate?: Date | undefined ;
  toDate?: Date | undefined ;
}

export function createPaymentIntentUrl(): string {
  let url_ = getBaseUrl() + "/api/payments/intent";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createPaymentIntentMutationKey(): MutationKey {
  return trimArrayEnd([
      'PaymentsControllerClient',
      'createPaymentIntent',
    ]);
}

/**
 * Create a payment intent
 * @return Returns client secret and payment provider information
 */
export function useCreatePaymentIntentMutation<TContext>(options?: Omit<UseMutationOptions<Types.PaymentIntentResponseDto, unknown, Types.CreatePaymentIntentDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PaymentIntentResponseDto, unknown, Types.CreatePaymentIntentDto, TContext> {
  const key = createPaymentIntentMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CreatePaymentIntentDto) => Client.createPaymentIntent(body),
    mutationKey: key,
  });
}
  
export function confirmPaymentUrl(): string {
  let url_ = getBaseUrl() + "/api/payments/confirm";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function confirmPaymentMutationKey(): MutationKey {
  return trimArrayEnd([
      'PaymentsControllerClient',
      'confirmPayment',
    ]);
}

/**
 * Confirm a payment
 * @return Returns the status of the payment intent
 */
export function useConfirmPaymentMutation<TContext>(options?: Omit<UseMutationOptions<Types.PaymentConfirmationResponseDto, unknown, Types.ConfirmPaymentDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PaymentConfirmationResponseDto, unknown, Types.ConfirmPaymentDto, TContext> {
  const key = confirmPaymentMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ConfirmPaymentDto) => Client.confirmPayment(body),
    mutationKey: key,
  });
}
  
export function processRefundUrl(): string {
  let url_ = getBaseUrl() + "/api/payments/refund";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function processRefundMutationKey(): MutationKey {
  return trimArrayEnd([
      'PaymentsControllerClient',
      'processRefund',
    ]);
}

/**
 * Process a refund
 * @return Returns the refund details
 */
export function useProcessRefundMutation<TContext>(options?: Omit<UseMutationOptions<Types.Anonymous, unknown, Types.ProcessRefundDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Anonymous, unknown, Types.ProcessRefundDto, TContext> {
  const key = processRefundMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ProcessRefundDto) => Client.processRefund(body),
    mutationKey: key,
  });
}
  
export function getTransactionsByOrderUrl(orderId: string): string {
  let url_ = getBaseUrl() + "/api/payments/transactions/order/{orderId}";
if (orderId === undefined || orderId === null)
  throw new Error("The parameter 'orderId' must be defined.");
url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getTransactionsByOrderDefaultOptions: Omit<UseQueryOptions<Types.Transaction[], unknown, Types.Transaction[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Transaction[], unknown, Types.Transaction[]>, 'queryFn'>> = {
};
export function getGetTransactionsByOrderDefaultOptions() {
  return getTransactionsByOrderDefaultOptions;
};
export function setGetTransactionsByOrderDefaultOptions(options: typeof getTransactionsByOrderDefaultOptions) {
  getTransactionsByOrderDefaultOptions = options;
}

export function getTransactionsByOrderQueryKey(orderId: string): QueryKey;
export function getTransactionsByOrderQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { orderId,  } = params[0] as GetTransactionsByOrderPaymentsControllerQueryParameters;

    return trimArrayEnd([
        'PaymentsControllerClient',
        'getTransactionsByOrder',
        orderId as any,
      ]);
  } else {
    return trimArrayEnd([
        'PaymentsControllerClient',
        'getTransactionsByOrder',
        ...params
      ]);
  }
}
export function __getTransactionsByOrder(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getTransactionsByOrder(
      context.queryKey[2] as string,axiosConfig    );
}

export function useGetTransactionsByOrderQuery<TSelectData = Types.Transaction[], TError = unknown>(dto: GetTransactionsByOrderPaymentsControllerQueryParameters, options?: Omit<UseQueryOptions<Types.Transaction[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get transactions by order ID
 * @return Returns all transactions for the order
 */
export function useGetTransactionsByOrderQuery<TSelectData = Types.Transaction[], TError = unknown>(orderId: string, options?: Omit<UseQueryOptions<Types.Transaction[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetTransactionsByOrderQuery<TSelectData = Types.Transaction[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Transaction[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let orderId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ orderId,  } = params[0] as GetTransactionsByOrderPaymentsControllerQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [orderId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Transaction[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getTransactionsByOrder(context, axiosConfig) : __getTransactionsByOrder,
    queryKey: getTransactionsByOrderQueryKey(orderId),
    ...getTransactionsByOrderDefaultOptions as unknown as Omit<UseQueryOptions<Types.Transaction[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get transactions by order ID
 * @return Returns all transactions for the order
 */
export function setGetTransactionsByOrderData(queryClient: QueryClient, updater: (data: Types.Transaction[] | undefined) => Types.Transaction[], orderId: string) {
  queryClient.setQueryData(getTransactionsByOrderQueryKey(orderId),
    updater
  );
}

/**
 * Get transactions by order ID
 * @return Returns all transactions for the order
 */
export function setGetTransactionsByOrderDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Transaction[] | undefined) => Types.Transaction[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getTransactionsByOrganizationUrl(organizationId: string, fromDate?: Date | undefined, toDate?: Date | undefined): string {
  let url_ = getBaseUrl() + "/api/payments/transactions/organization/{organizationId}?";
if (organizationId === undefined || organizationId === null)
  throw new Error("The parameter 'organizationId' must be defined.");
url_ = url_.replace("{organizationId}", encodeURIComponent("" + organizationId));
if (fromDate === null)
    throw new Error("The parameter 'fromDate' cannot be null.");
else if (fromDate !== undefined)
    url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
if (toDate === null)
    throw new Error("The parameter 'toDate' cannot be null.");
else if (toDate !== undefined)
    url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getTransactionsByOrganizationDefaultOptions: Omit<UseQueryOptions<Types.Transaction[], unknown, Types.Transaction[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.Transaction[], unknown, Types.Transaction[]>, 'queryFn'>> = {
};
export function getGetTransactionsByOrganizationDefaultOptions() {
  return getTransactionsByOrganizationDefaultOptions;
};
export function setGetTransactionsByOrganizationDefaultOptions(options: typeof getTransactionsByOrganizationDefaultOptions) {
  getTransactionsByOrganizationDefaultOptions = options;
}

export function getTransactionsByOrganizationQueryKey(dto: GetTransactionsByOrganizationPaymentsControllerQueryParameters): QueryKey;
export function getTransactionsByOrganizationQueryKey(organizationId: string, fromDate?: Date | undefined, toDate?: Date | undefined): QueryKey;
export function getTransactionsByOrganizationQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { organizationId, fromDate, toDate,  } = params[0] as GetTransactionsByOrganizationPaymentsControllerQueryParameters;

    return trimArrayEnd([
        'PaymentsControllerClient',
        'getTransactionsByOrganization',
        organizationId as any,
        fromDate as any,
        toDate as any,
      ]);
  } else {
    return trimArrayEnd([
        'PaymentsControllerClient',
        'getTransactionsByOrganization',
        ...params
      ]);
  }
}
export function __getTransactionsByOrganization(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getTransactionsByOrganization(
      context.queryKey[2] as string,       context.queryKey[3] as Date | undefined,       context.queryKey[4] as Date | undefined,axiosConfig    );
}

export function useGetTransactionsByOrganizationQuery<TSelectData = Types.Transaction[], TError = unknown>(dto: GetTransactionsByOrganizationPaymentsControllerQueryParameters, options?: Omit<UseQueryOptions<Types.Transaction[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get transactions by organization ID
 * @param fromDate (optional) 
 * @param toDate (optional) 
 * @return Returns all transactions for the organization
 */
export function useGetTransactionsByOrganizationQuery<TSelectData = Types.Transaction[], TError = unknown>(organizationId: string, fromDate?: Date | undefined, toDate?: Date | undefined, options?: Omit<UseQueryOptions<Types.Transaction[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetTransactionsByOrganizationQuery<TSelectData = Types.Transaction[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Transaction[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let organizationId: any = undefined;
  let fromDate: any = undefined;
  let toDate: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ organizationId, fromDate, toDate,  } = params[0] as GetTransactionsByOrganizationPaymentsControllerQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [organizationId, fromDate, toDate, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Transaction[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getTransactionsByOrganization(context, axiosConfig) : __getTransactionsByOrganization,
    queryKey: getTransactionsByOrganizationQueryKey(organizationId, fromDate, toDate),
    ...getTransactionsByOrganizationDefaultOptions as unknown as Omit<UseQueryOptions<Types.Transaction[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get transactions by organization ID
 * @param fromDate (optional) 
 * @param toDate (optional) 
 * @return Returns all transactions for the organization
 */
export function setGetTransactionsByOrganizationData(queryClient: QueryClient, updater: (data: Types.Transaction[] | undefined) => Types.Transaction[], organizationId: string, fromDate?: Date | undefined, toDate?: Date | undefined) {
  queryClient.setQueryData(getTransactionsByOrganizationQueryKey(organizationId, fromDate, toDate),
    updater
  );
}

/**
 * Get transactions by organization ID
 * @param fromDate (optional) 
 * @param toDate (optional) 
 * @return Returns all transactions for the organization
 */
export function setGetTransactionsByOrganizationDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Transaction[] | undefined) => Types.Transaction[]) {
  queryClient.setQueryData(queryKey, updater);
}