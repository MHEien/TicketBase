//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import type { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export * as AppControllerClient from './api-client/AppControllerClient';

export * as AppControllerQuery from './api-client/AppControllerQuery';



export * as AuthControllerClient from './api-client/AuthControllerClient';

export * as AuthControllerQuery from './api-client/AuthControllerQuery';



export * as DepartmentsControllerClient from './api-client/DepartmentsControllerClient';

export * as DepartmentsControllerQuery from './api-client/DepartmentsControllerQuery';



export * as EventsControllerClient from './api-client/EventsControllerClient';

export * as EventsControllerQuery from './api-client/EventsControllerQuery';



export * as TicketTypesControllerClient from './api-client/TicketTypesControllerClient';

export * as TicketTypesControllerQuery from './api-client/TicketTypesControllerQuery';



export * as TicketsControllerClient from './api-client/TicketsControllerClient';

export * as TicketsControllerQuery from './api-client/TicketsControllerQuery';



export * as CartsControllerClient from './api-client/CartsControllerClient';

export * as CartsControllerQuery from './api-client/CartsControllerQuery';



export * as OrdersControllerClient from './api-client/OrdersControllerClient';

export * as OrdersControllerQuery from './api-client/OrdersControllerQuery';



export * as PaymentsControllerClient from './api-client/PaymentsControllerClient';

export * as PaymentsControllerQuery from './api-client/PaymentsControllerQuery';



export * as PluginsControllerClient from './api-client/PluginsControllerClient';

export * as PluginsControllerQuery from './api-client/PluginsControllerQuery';



export * as ProxyRequestClient from './api-client/ProxyRequestClient';

export * as ProxyRequestQuery from './api-client/ProxyRequestQuery';



export * as BundleProxyControllerClient from './api-client/BundleProxyControllerClient';

export * as BundleProxyControllerQuery from './api-client/BundleProxyControllerQuery';



export * as CustomersControllerClient from './api-client/CustomersControllerClient';

export * as CustomersControllerQuery from './api-client/CustomersControllerQuery';



export * as AnalyticsControllerClient from './api-client/AnalyticsControllerClient';

export * as AnalyticsControllerQuery from './api-client/AnalyticsControllerQuery';



export * as ActivitiesControllerClient from './api-client/ActivitiesControllerClient';

export * as ActivitiesControllerQuery from './api-client/ActivitiesControllerQuery';



//-----Types.File-----
export class LoginDto implements ILoginDto {
    /** User email */
    email!: string;
    /** User password */
    password!: string;

    [key: string]: any;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginDto {
    /** User email */
    email: string;
    /** User password */
    password: string;

    [key: string]: any;
}

export class LoginResponseDto implements ILoginResponseDto {
    id!: string;
    name!: string;
    email!: string;
    role!: string;
    permissions!: string[];
    organizationId!: string;
    accessToken!: string;
    refreshToken!: string;
    expiresIn!: number;

    [key: string]: any;

    constructor(data?: ILoginResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.permissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.role = _data["role"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.organizationId = _data["organizationId"];
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.expiresIn = _data["expiresIn"];
        }
    }

    static fromJS(data: any): LoginResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["role"] = this.role;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["organizationId"] = this.organizationId;
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["expiresIn"] = this.expiresIn;
        return data;
    }
}

export interface ILoginResponseDto {
    id: string;
    name: string;
    email: string;
    role: string;
    permissions: string[];
    organizationId: string;
    accessToken: string;
    refreshToken: string;
    expiresIn: number;

    [key: string]: any;
}

export class RegisterDto implements IRegisterDto {
    /** User full name */
    name!: string;
    /** User email address */
    email!: string;
    /** User password */
    password!: string;
    /** Organization name */
    organizationName!: string;
    /** Organization slug (auto-generated if not provided) */
    organizationSlug?: string;
    /** User role within the organization */
    role?: string;

    [key: string]: any;

    constructor(data?: IRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.organizationName = _data["organizationName"];
            this.organizationSlug = _data["organizationSlug"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): RegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["email"] = this.email;
        data["password"] = this.password;
        data["organizationName"] = this.organizationName;
        data["organizationSlug"] = this.organizationSlug;
        data["role"] = this.role;
        return data;
    }
}

export interface IRegisterDto {
    /** User full name */
    name: string;
    /** User email address */
    email: string;
    /** User password */
    password: string;
    /** Organization name */
    organizationName: string;
    /** Organization slug (auto-generated if not provided) */
    organizationSlug?: string;
    /** User role within the organization */
    role?: string;

    [key: string]: any;
}

export class TokenResponseDto implements ITokenResponseDto {
    accessToken!: string;
    refreshToken!: string;
    expiresIn!: number;

    [key: string]: any;

    constructor(data?: ITokenResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.expiresIn = _data["expiresIn"];
        }
    }

    static fromJS(data: any): TokenResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TokenResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["expiresIn"] = this.expiresIn;
        return data;
    }
}

export interface ITokenResponseDto {
    accessToken: string;
    refreshToken: string;
    expiresIn: number;

    [key: string]: any;
}

export class RefreshTokenDto implements IRefreshTokenDto {
    /** Refresh token received from login or registration */
    refreshToken!: string;

    [key: string]: any;

    constructor(data?: IRefreshTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenDto {
    /** Refresh token received from login or registration */
    refreshToken: string;

    [key: string]: any;
}

export class DepartmentNotificationPreferencesDto implements IDepartmentNotificationPreferencesDto {
    /** Notify on new tickets */
    newTicket?: boolean;
    /** Notify on ticket assignments */
    ticketAssigned?: boolean;
    /** Notify on ticket closures */
    ticketClosed?: boolean;
    /** Send daily summary */
    dailySummary?: boolean;

    [key: string]: any;

    constructor(data?: IDepartmentNotificationPreferencesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.newTicket = _data["newTicket"];
            this.ticketAssigned = _data["ticketAssigned"];
            this.ticketClosed = _data["ticketClosed"];
            this.dailySummary = _data["dailySummary"];
        }
    }

    static fromJS(data: any): DepartmentNotificationPreferencesDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentNotificationPreferencesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["newTicket"] = this.newTicket;
        data["ticketAssigned"] = this.ticketAssigned;
        data["ticketClosed"] = this.ticketClosed;
        data["dailySummary"] = this.dailySummary;
        return data;
    }
}

export interface IDepartmentNotificationPreferencesDto {
    /** Notify on new tickets */
    newTicket?: boolean;
    /** Notify on ticket assignments */
    ticketAssigned?: boolean;
    /** Notify on ticket closures */
    ticketClosed?: boolean;
    /** Send daily summary */
    dailySummary?: boolean;

    [key: string]: any;
}

export class DepartmentCustomFieldDto implements IDepartmentCustomFieldDto {
    /** Field key */
    key!: string;
    /** Field label */
    label!: string;
    /** Field type */
    type!: DepartmentCustomFieldDtoType;
    /** Field options for select type */
    options?: string[];
    /** Whether the field is required */
    required?: boolean;

    [key: string]: any;

    constructor(data?: IDepartmentCustomFieldDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.key = _data["key"];
            this.label = _data["label"];
            this.type = _data["type"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(item);
            }
            this.required = _data["required"];
        }
    }

    static fromJS(data: any): DepartmentCustomFieldDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentCustomFieldDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["key"] = this.key;
        data["label"] = this.label;
        data["type"] = this.type;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item);
        }
        data["required"] = this.required;
        return data;
    }
}

export interface IDepartmentCustomFieldDto {
    /** Field key */
    key: string;
    /** Field label */
    label: string;
    /** Field type */
    type: DepartmentCustomFieldDtoType;
    /** Field options for select type */
    options?: string[];
    /** Whether the field is required */
    required?: boolean;

    [key: string]: any;
}

export class DepartmentSettingsDto implements IDepartmentSettingsDto {
    /** Department color */
    color?: string;
    /** Department icon */
    icon?: string;
    /** Contact email */
    contactEmail?: string;
    /** Contact phone */
    contactPhone?: string;
    /** Department location */
    location?: string;
    /** Default ticket assignee ID */
    defaultTicketAssignee?: string;
    /** Auto-assign tickets */
    autoAssignTickets?: boolean;
    /** Notification preferences */
    notificationPreferences?: DepartmentNotificationPreferencesDto;
    /** Custom fields */
    customFields?: DepartmentCustomFieldDto[];

    [key: string]: any;

    constructor(data?: IDepartmentSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.color = _data["color"];
            this.icon = _data["icon"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.location = _data["location"];
            this.defaultTicketAssignee = _data["defaultTicketAssignee"];
            this.autoAssignTickets = _data["autoAssignTickets"];
            this.notificationPreferences = _data["notificationPreferences"] ? DepartmentNotificationPreferencesDto.fromJS(_data["notificationPreferences"]) : <any>null;
            if (Array.isArray(_data["customFields"])) {
                this.customFields = [] as any;
                for (let item of _data["customFields"])
                    this.customFields!.push(DepartmentCustomFieldDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DepartmentSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new DepartmentSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["color"] = this.color;
        data["icon"] = this.icon;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["location"] = this.location;
        data["defaultTicketAssignee"] = this.defaultTicketAssignee;
        data["autoAssignTickets"] = this.autoAssignTickets;
        data["notificationPreferences"] = this.notificationPreferences ? this.notificationPreferences.toJSON() : this.notificationPreferences;
        if (Array.isArray(this.customFields)) {
            data["customFields"] = [];
            for (let item of this.customFields)
                data["customFields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDepartmentSettingsDto {
    /** Department color */
    color?: string;
    /** Department icon */
    icon?: string;
    /** Contact email */
    contactEmail?: string;
    /** Contact phone */
    contactPhone?: string;
    /** Department location */
    location?: string;
    /** Default ticket assignee ID */
    defaultTicketAssignee?: string;
    /** Auto-assign tickets */
    autoAssignTickets?: boolean;
    /** Notification preferences */
    notificationPreferences?: DepartmentNotificationPreferencesDto;
    /** Custom fields */
    customFields?: DepartmentCustomFieldDto[];

    [key: string]: any;
}

export class CreateDepartmentDto implements ICreateDepartmentDto {
    /** Department name */
    name!: string;
    /** Department description */
    description?: string;
    /** URL-friendly identifier */
    slug!: string;
    /** Organization ID */
    organizationId!: string;
    /** Department head user ID */
    headId?: string;
    /** Parent department ID */
    parentDepartmentId?: string;
    /** Department code or identifier */
    code?: string;
    /** Department settings */
    settings?: DepartmentSettingsDto;
    /** Whether the department is active */
    isActive?: boolean;

    [key: string]: any;

    constructor(data?: ICreateDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.organizationId = _data["organizationId"];
            this.headId = _data["headId"];
            this.parentDepartmentId = _data["parentDepartmentId"];
            this.code = _data["code"];
            this.settings = _data["settings"] ? DepartmentSettingsDto.fromJS(_data["settings"]) : <any>null;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["organizationId"] = this.organizationId;
        data["headId"] = this.headId;
        data["parentDepartmentId"] = this.parentDepartmentId;
        data["code"] = this.code;
        data["settings"] = this.settings ? this.settings.toJSON() : this.settings;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateDepartmentDto {
    /** Department name */
    name: string;
    /** Department description */
    description?: string;
    /** URL-friendly identifier */
    slug: string;
    /** Organization ID */
    organizationId: string;
    /** Department head user ID */
    headId?: string;
    /** Parent department ID */
    parentDepartmentId?: string;
    /** Department code or identifier */
    code?: string;
    /** Department settings */
    settings?: DepartmentSettingsDto;
    /** Whether the department is active */
    isActive?: boolean;

    [key: string]: any;
}

export class Department implements IDepartment {
    /** Unique identifier for the department */
    id!: string;
    /** Department name */
    name!: string;
    /** Department description */
    description?: string;
    /** URL-friendly identifier */
    slug!: string;
    /** ID of the organization the department belongs to */
    organizationId!: string;
    /** Department head user ID */
    headId?: string;
    /** Parent department ID */
    parentDepartmentId?: string;
    /** Department code or identifier */
    code?: string;
    /** When the department was created */
    createdAt!: Date;
    /** When the department was last updated */
    updatedAt!: Date;
    /** Department settings and metadata */
    settings!: any;
    /** Whether the department is active */
    isActive!: boolean;

    [key: string]: any;

    constructor(data?: IDepartment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.organizationId = _data["organizationId"];
            this.headId = _data["headId"];
            this.parentDepartmentId = _data["parentDepartmentId"];
            this.code = _data["code"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>null;
            this.settings = _data["settings"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): Department {
        data = typeof data === 'object' ? data : {};
        let result = new Department();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["organizationId"] = this.organizationId;
        data["headId"] = this.headId;
        data["parentDepartmentId"] = this.parentDepartmentId;
        data["code"] = this.code;
        data["createdAt"] = this.createdAt && this.createdAt.toISOString();
        data["updatedAt"] = this.updatedAt && this.updatedAt.toISOString();
        data["settings"] = this.settings;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IDepartment {
    /** Unique identifier for the department */
    id: string;
    /** Department name */
    name: string;
    /** Department description */
    description?: string;
    /** URL-friendly identifier */
    slug: string;
    /** ID of the organization the department belongs to */
    organizationId: string;
    /** Department head user ID */
    headId?: string;
    /** Parent department ID */
    parentDepartmentId?: string;
    /** Department code or identifier */
    code?: string;
    /** When the department was created */
    createdAt: Date;
    /** When the department was last updated */
    updatedAt: Date;
    /** Department settings and metadata */
    settings: any;
    /** Whether the department is active */
    isActive: boolean;

    [key: string]: any;
}

export class UpdateDepartmentDto implements IUpdateDepartmentDto {
    /** Department name */
    name?: string;
    /** Department description */
    description?: string;
    /** URL-friendly identifier */
    slug?: string;
    /** Organization ID */
    organizationId?: string;
    /** Department head user ID */
    headId?: string;
    /** Parent department ID */
    parentDepartmentId?: string;
    /** Department code or identifier */
    code?: string;
    /** Department settings */
    settings?: DepartmentSettingsDto;
    /** Whether the department is active */
    isActive?: boolean;

    [key: string]: any;

    constructor(data?: IUpdateDepartmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.slug = _data["slug"];
            this.organizationId = _data["organizationId"];
            this.headId = _data["headId"];
            this.parentDepartmentId = _data["parentDepartmentId"];
            this.code = _data["code"];
            this.settings = _data["settings"] ? DepartmentSettingsDto.fromJS(_data["settings"]) : <any>null;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateDepartmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDepartmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["slug"] = this.slug;
        data["organizationId"] = this.organizationId;
        data["headId"] = this.headId;
        data["parentDepartmentId"] = this.parentDepartmentId;
        data["code"] = this.code;
        data["settings"] = this.settings ? this.settings.toJSON() : this.settings;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateDepartmentDto {
    /** Department name */
    name?: string;
    /** Department description */
    description?: string;
    /** URL-friendly identifier */
    slug?: string;
    /** Organization ID */
    organizationId?: string;
    /** Department head user ID */
    headId?: string;
    /** Parent department ID */
    parentDepartmentId?: string;
    /** Department code or identifier */
    code?: string;
    /** Department settings */
    settings?: DepartmentSettingsDto;
    /** Whether the department is active */
    isActive?: boolean;

    [key: string]: any;
}

export class CreateEventDto implements ICreateEventDto {

    [key: string]: any;

    constructor(data?: ICreateEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): CreateEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ICreateEventDto {

    [key: string]: any;
}

export class Organization implements IOrganization {
    /** Unique identifier for the organization */
    id!: string;
    /** Organization name */
    name!: string;
    /** URL-friendly identifier */
    slug!: string;
    /** Organization email */
    email!: string;
    /** Organization phone */
    phone?: string;
    /** Organization website */
    website?: string;
    /** Organization address */
    address?: any;
    /** Organization logo URL */
    logo?: string;
    /** Organization favicon URL */
    favicon?: string;
    /** When the organization was created */
    createdAt!: Date;
    /** When the organization was last updated */
    updatedAt!: Date;
    /** Organization plan type */
    plan!: OrganizationPlan;
    /** Organization settings */
    settings!: any;
    /** Subscription ID */
    subscriptionId?: string;
    /** Custom domain */
    customDomain?: string;
    /** Domain verification status */
    domainVerified?: boolean;
    /** Domain verification token */
    domainVerificationToken?: string;
    /** Default checkout message */
    checkoutMessage?: string;
    /** Default confirmation email template */
    emailTemplate?: string;

    [key: string]: any;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.plan = OrganizationPlan.Free;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.website = _data["website"];
            this.address = _data["address"];
            this.logo = _data["logo"];
            this.favicon = _data["favicon"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>null;
            this.plan = _data["plan"] !== undefined ? _data["plan"] : OrganizationPlan.Free;
            this.settings = _data["settings"];
            this.subscriptionId = _data["subscriptionId"];
            this.customDomain = _data["customDomain"];
            this.domainVerified = _data["domainVerified"];
            this.domainVerificationToken = _data["domainVerificationToken"];
            this.checkoutMessage = _data["checkoutMessage"];
            this.emailTemplate = _data["emailTemplate"];
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["website"] = this.website;
        data["address"] = this.address;
        data["logo"] = this.logo;
        data["favicon"] = this.favicon;
        data["createdAt"] = this.createdAt && this.createdAt.toISOString();
        data["updatedAt"] = this.updatedAt && this.updatedAt.toISOString();
        data["plan"] = this.plan;
        data["settings"] = this.settings;
        data["subscriptionId"] = this.subscriptionId;
        data["customDomain"] = this.customDomain;
        data["domainVerified"] = this.domainVerified;
        data["domainVerificationToken"] = this.domainVerificationToken;
        data["checkoutMessage"] = this.checkoutMessage;
        data["emailTemplate"] = this.emailTemplate;
        return data;
    }
}

export interface IOrganization {
    /** Unique identifier for the organization */
    id: string;
    /** Organization name */
    name: string;
    /** URL-friendly identifier */
    slug: string;
    /** Organization email */
    email: string;
    /** Organization phone */
    phone?: string;
    /** Organization website */
    website?: string;
    /** Organization address */
    address?: any;
    /** Organization logo URL */
    logo?: string;
    /** Organization favicon URL */
    favicon?: string;
    /** When the organization was created */
    createdAt: Date;
    /** When the organization was last updated */
    updatedAt: Date;
    /** Organization plan type */
    plan: OrganizationPlan;
    /** Organization settings */
    settings: any;
    /** Subscription ID */
    subscriptionId?: string;
    /** Custom domain */
    customDomain?: string;
    /** Domain verification status */
    domainVerified?: boolean;
    /** Domain verification token */
    domainVerificationToken?: string;
    /** Default checkout message */
    checkoutMessage?: string;
    /** Default confirmation email template */
    emailTemplate?: string;

    [key: string]: any;
}

export class User implements IUser {
    /** Unique identifier for the user */
    id!: string;
    /** User's full name */
    name!: string;
    /** User's email address */
    email!: string;
    /** User's hashed password */
    password!: string;
    /** User's avatar URL */
    avatar?: string;
    /** User's role in the organization */
    role!: UserRole;
    /** User's permissions */
    permissions!: string[];
    /** ID of the organization the user belongs to */
    organizationId!: string;
    /** ID of the department the user belongs to */
    departmentId?: string;
    /** When the user was created */
    createdAt!: Date;
    /** When the user was last active */
    lastActive!: Date;
    /** User's status */
    status!: UserStatus;
    /** Whether two-factor authentication is enabled */
    twoFactorEnabled!: boolean;
    /** Two-factor authentication secret */
    twoFactorSecret?: string;

    [key: string]: any;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = UserRole.Manager;
            this.permissions = [];
            this.status = UserStatus.Pending;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.avatar = _data["avatar"];
            this.role = _data["role"] !== undefined ? _data["role"] : UserRole.Manager;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.organizationId = _data["organizationId"];
            this.departmentId = _data["departmentId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.lastActive = _data["lastActive"] ? new Date(_data["lastActive"].toString()) : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : UserStatus.Pending;
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.twoFactorSecret = _data["twoFactorSecret"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["password"] = this.password;
        data["avatar"] = this.avatar;
        data["role"] = this.role;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["organizationId"] = this.organizationId;
        data["departmentId"] = this.departmentId;
        data["createdAt"] = this.createdAt && this.createdAt.toISOString();
        data["lastActive"] = this.lastActive && this.lastActive.toISOString();
        data["status"] = this.status;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["twoFactorSecret"] = this.twoFactorSecret;
        return data;
    }
}

export interface IUser {
    /** Unique identifier for the user */
    id: string;
    /** User's full name */
    name: string;
    /** User's email address */
    email: string;
    /** User's hashed password */
    password: string;
    /** User's avatar URL */
    avatar?: string;
    /** User's role in the organization */
    role: UserRole;
    /** User's permissions */
    permissions: string[];
    /** ID of the organization the user belongs to */
    organizationId: string;
    /** ID of the department the user belongs to */
    departmentId?: string;
    /** When the user was created */
    createdAt: Date;
    /** When the user was last active */
    lastActive: Date;
    /** User's status */
    status: UserStatus;
    /** Whether two-factor authentication is enabled */
    twoFactorEnabled: boolean;
    /** Two-factor authentication secret */
    twoFactorSecret?: string;

    [key: string]: any;
}

export class TicketType implements ITicketType {

    [key: string]: any;

    constructor(data?: ITicketType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): TicketType {
        data = typeof data === 'object' ? data : {};
        let result = new TicketType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ITicketType {

    [key: string]: any;
}

export class EventResponseDto implements IEventResponseDto {
    /** Unique identifier of the event */
    id!: string;
    /** Organization ID that owns this event */
    organizationId!: string;
    /** Organization that owns this event */
    organization!: Organization;
    /** Title of the event */
    title!: string;
    /** Full description of the event */
    description!: string;
    /** Short description for previews */
    shortDescription?: string;
    /** Category of the event */
    category!: string;
    /** Start date of the event */
    startDate!: Date;
    /** End date of the event */
    endDate!: Date;
    /** Start time in HH:mm format */
    startTime!: string;
    /** End time in HH:mm format */
    endTime!: string;
    /** Timezone of the event */
    timeZone!: string;
    /** Type of event location */
    locationType!: EventResponseDtoLocationType;
    /** Name of the venue */
    venueName?: string;
    /** Physical address of the venue */
    address?: string;
    /** City of the venue */
    city?: string;
    /** State/Province of the venue */
    state?: string;
    /** Postal/ZIP code of the venue */
    zipCode?: string;
    /** Country of the venue */
    country?: string;
    /** URL for virtual events */
    virtualEventUrl?: string;
    /** URL of the featured image */
    featuredImage?: string;
    /** URLs of additional event images */
    galleryImages?: string[];
    /** Current status of the event */
    status!: EventResponseDtoStatus;
    /** Visibility setting of the event */
    visibility!: EventResponseDtoVisibility;
    /** When the event was created */
    createdAt!: Date;
    /** When the event was last updated */
    updatedAt!: Date;
    /** ID of the user who created the event */
    createdBy!: string;
    /** ID of the user who last updated the event */
    updatedBy!: string;
    /** User who created the event */
    creator!: User;
    /** User who last updated the event */
    updater!: User;
    /** Available ticket types for this event */
    ticketTypes!: TicketType[];
    /** When ticket sales begin */
    salesStartDate?: Date;
    /** When ticket sales end */
    salesEndDate?: Date;
    /** SEO optimized title */
    seoTitle?: string;
    /** SEO optimized description */
    seoDescription?: string;
    /** Event tags for categorization */
    tags?: string[];
    /** Total number of tickets sold */
    totalTicketsSold!: number;
    /** Total revenue from ticket sales */
    totalRevenue!: number;
    /** Maximum number of attendees */
    capacity!: number;

    [key: string]: any;

    constructor(data?: IEventResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.organization = new Organization();
            this.locationType = EventResponseDtoLocationType.Physical;
            this.status = EventResponseDtoStatus.Draft;
            this.visibility = EventResponseDtoVisibility.Public;
            this.creator = new User();
            this.updater = new User();
            this.ticketTypes = [];
            this.totalTicketsSold = 0;
            this.totalRevenue = 0;
            this.capacity = 0;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.organizationId = _data["organizationId"];
            this.organization = _data["organization"] ? Organization.fromJS(_data["organization"]) : new Organization();
            this.title = _data["title"];
            this.description = _data["description"];
            this.shortDescription = _data["shortDescription"];
            this.category = _data["category"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.timeZone = _data["timeZone"];
            this.locationType = _data["locationType"] !== undefined ? _data["locationType"] : EventResponseDtoLocationType.Physical;
            this.venueName = _data["venueName"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.country = _data["country"];
            this.virtualEventUrl = _data["virtualEventUrl"];
            this.featuredImage = _data["featuredImage"];
            if (Array.isArray(_data["galleryImages"])) {
                this.galleryImages = [] as any;
                for (let item of _data["galleryImages"])
                    this.galleryImages!.push(item);
            }
            this.status = _data["status"] !== undefined ? _data["status"] : EventResponseDtoStatus.Draft;
            this.visibility = _data["visibility"] !== undefined ? _data["visibility"] : EventResponseDtoVisibility.Public;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>null;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.creator = _data["creator"] ? User.fromJS(_data["creator"]) : new User();
            this.updater = _data["updater"] ? User.fromJS(_data["updater"]) : new User();
            if (Array.isArray(_data["ticketTypes"])) {
                this.ticketTypes = [] as any;
                for (let item of _data["ticketTypes"])
                    this.ticketTypes!.push(TicketType.fromJS(item));
            }
            this.salesStartDate = _data["salesStartDate"] ? new Date(_data["salesStartDate"].toString()) : <any>null;
            this.salesEndDate = _data["salesEndDate"] ? new Date(_data["salesEndDate"].toString()) : <any>null;
            this.seoTitle = _data["seoTitle"];
            this.seoDescription = _data["seoDescription"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.totalTicketsSold = _data["totalTicketsSold"] !== undefined ? _data["totalTicketsSold"] : 0;
            this.totalRevenue = _data["totalRevenue"] !== undefined ? _data["totalRevenue"] : 0;
            this.capacity = _data["capacity"] !== undefined ? _data["capacity"] : 0;
        }
    }

    static fromJS(data: any): EventResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        data["organization"] = this.organization ? this.organization.toJSON() : this.organization;
        data["title"] = this.title;
        data["description"] = this.description;
        data["shortDescription"] = this.shortDescription;
        data["category"] = this.category;
        data["startDate"] = this.startDate && this.startDate.toISOString();
        data["endDate"] = this.endDate && this.endDate.toISOString();
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["timeZone"] = this.timeZone;
        data["locationType"] = this.locationType;
        data["venueName"] = this.venueName;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["country"] = this.country;
        data["virtualEventUrl"] = this.virtualEventUrl;
        data["featuredImage"] = this.featuredImage;
        if (Array.isArray(this.galleryImages)) {
            data["galleryImages"] = [];
            for (let item of this.galleryImages)
                data["galleryImages"].push(item);
        }
        data["status"] = this.status;
        data["visibility"] = this.visibility;
        data["createdAt"] = this.createdAt && this.createdAt.toISOString();
        data["updatedAt"] = this.updatedAt && this.updatedAt.toISOString();
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["creator"] = this.creator ? this.creator.toJSON() : this.creator;
        data["updater"] = this.updater ? this.updater.toJSON() : this.updater;
        if (Array.isArray(this.ticketTypes)) {
            data["ticketTypes"] = [];
            for (let item of this.ticketTypes)
                data["ticketTypes"].push(item.toJSON());
        }
        data["salesStartDate"] = this.salesStartDate && this.salesStartDate.toISOString();
        data["salesEndDate"] = this.salesEndDate && this.salesEndDate.toISOString();
        data["seoTitle"] = this.seoTitle;
        data["seoDescription"] = this.seoDescription;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["totalTicketsSold"] = this.totalTicketsSold;
        data["totalRevenue"] = this.totalRevenue;
        data["capacity"] = this.capacity;
        return data;
    }
}

export interface IEventResponseDto {
    /** Unique identifier of the event */
    id: string;
    /** Organization ID that owns this event */
    organizationId: string;
    /** Organization that owns this event */
    organization: Organization;
    /** Title of the event */
    title: string;
    /** Full description of the event */
    description: string;
    /** Short description for previews */
    shortDescription?: string;
    /** Category of the event */
    category: string;
    /** Start date of the event */
    startDate: Date;
    /** End date of the event */
    endDate: Date;
    /** Start time in HH:mm format */
    startTime: string;
    /** End time in HH:mm format */
    endTime: string;
    /** Timezone of the event */
    timeZone: string;
    /** Type of event location */
    locationType: EventResponseDtoLocationType;
    /** Name of the venue */
    venueName?: string;
    /** Physical address of the venue */
    address?: string;
    /** City of the venue */
    city?: string;
    /** State/Province of the venue */
    state?: string;
    /** Postal/ZIP code of the venue */
    zipCode?: string;
    /** Country of the venue */
    country?: string;
    /** URL for virtual events */
    virtualEventUrl?: string;
    /** URL of the featured image */
    featuredImage?: string;
    /** URLs of additional event images */
    galleryImages?: string[];
    /** Current status of the event */
    status: EventResponseDtoStatus;
    /** Visibility setting of the event */
    visibility: EventResponseDtoVisibility;
    /** When the event was created */
    createdAt: Date;
    /** When the event was last updated */
    updatedAt: Date;
    /** ID of the user who created the event */
    createdBy: string;
    /** ID of the user who last updated the event */
    updatedBy: string;
    /** User who created the event */
    creator: User;
    /** User who last updated the event */
    updater: User;
    /** Available ticket types for this event */
    ticketTypes: TicketType[];
    /** When ticket sales begin */
    salesStartDate?: Date;
    /** When ticket sales end */
    salesEndDate?: Date;
    /** SEO optimized title */
    seoTitle?: string;
    /** SEO optimized description */
    seoDescription?: string;
    /** Event tags for categorization */
    tags?: string[];
    /** Total number of tickets sold */
    totalTicketsSold: number;
    /** Total revenue from ticket sales */
    totalRevenue: number;
    /** Maximum number of attendees */
    capacity: number;

    [key: string]: any;
}

export class UpdateEventDto implements IUpdateEventDto {

    [key: string]: any;

    constructor(data?: IUpdateEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): UpdateEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IUpdateEventDto {

    [key: string]: any;
}

export class CreateTicketTypeDto implements ICreateTicketTypeDto {

    [key: string]: any;

    constructor(data?: ICreateTicketTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): CreateTicketTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface ICreateTicketTypeDto {

    [key: string]: any;
}

export class UpdateTicketTypeDto implements IUpdateTicketTypeDto {

    [key: string]: any;

    constructor(data?: IUpdateTicketTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): UpdateTicketTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTicketTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

export interface IUpdateTicketTypeDto {

    [key: string]: any;
}

export class CreateCartDto implements ICreateCartDto {
    /** Organization ID */
    organizationId!: string;
    /** Event ID */
    eventId!: string;
    /** User ID (optional for guest checkout) */
    userId?: string;
    /** Session ID for tracking anonymous carts */
    sessionId?: string;

    [key: string]: any;

    constructor(data?: ICreateCartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.organizationId = _data["organizationId"];
            this.eventId = _data["eventId"];
            this.userId = _data["userId"];
            this.sessionId = _data["sessionId"];
        }
    }

    static fromJS(data: any): CreateCartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["organizationId"] = this.organizationId;
        data["eventId"] = this.eventId;
        data["userId"] = this.userId;
        data["sessionId"] = this.sessionId;
        return data;
    }
}

export interface ICreateCartDto {
    /** Organization ID */
    organizationId: string;
    /** Event ID */
    eventId: string;
    /** User ID (optional for guest checkout) */
    userId?: string;
    /** Session ID for tracking anonymous carts */
    sessionId?: string;

    [key: string]: any;
}

/** Item type */
export enum CartItemType {
    Ticket = "ticket",
    Merchandise = "merchandise",
    Fee = "fee",
}

export class CartItem implements ICartItem {
    /** Unique identifier */
    id!: string;
    /** Cart ID */
    cartId!: string;
    /** Ticket type ID */
    ticketTypeId?: string;
    /** Item name */
    name!: string;
    /** Quantity */
    quantity!: number;
    /** Unit price */
    unitPrice!: number;
    /** Subtotal */
    subtotal!: number;
    /** Item type */
    type!: CartItemType;
    /** Additional metadata (JSON) */
    metadata?: any;

    [key: string]: any;

    constructor(data?: ICartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.cartId = _data["cartId"];
            this.ticketTypeId = _data["ticketTypeId"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.subtotal = _data["subtotal"];
            this.type = _data["type"];
            this.metadata = _data["metadata"];
        }
    }

    static fromJS(data: any): CartItem {
        data = typeof data === 'object' ? data : {};
        let result = new CartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["cartId"] = this.cartId;
        data["ticketTypeId"] = this.ticketTypeId;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["subtotal"] = this.subtotal;
        data["type"] = this.type;
        data["metadata"] = this.metadata;
        return data;
    }
}

export interface ICartItem {
    /** Unique identifier */
    id: string;
    /** Cart ID */
    cartId: string;
    /** Ticket type ID */
    ticketTypeId?: string;
    /** Item name */
    name: string;
    /** Quantity */
    quantity: number;
    /** Unit price */
    unitPrice: number;
    /** Subtotal */
    subtotal: number;
    /** Item type */
    type: CartItemType;
    /** Additional metadata (JSON) */
    metadata?: any;

    [key: string]: any;
}

/** Cart status */
export enum CartStatus {
    Active = "active",
    Abandoned = "abandoned",
    Converted = "converted",
    Expired = "expired",
}

export class Cart implements ICart {
    /** Unique identifier */
    id!: string;
    /** Organization ID */
    organizationId!: string;
    /** Event ID */
    eventId!: string;
    /** User ID (optional for guest checkout) */
    userId?: string;
    /** Session ID for tracking anonymous carts */
    sessionId!: string;
    /** Cart items */
    items!: CartItem[];
    /** Customer information (JSON) */
    customer?: any;
    /** Subtotal amount */
    subtotal!: number;
    /** Service fees amount */
    fees!: number;
    /** Tax amount */
    taxes!: number;
    /** Total amount */
    total!: number;
    /** Currency */
    currency!: string;
    /** Discount code (if applied) */
    discountCode?: string;
    /** Discount amount */
    discountAmount?: number;
    /** Creation timestamp */
    createdAt!: Date;
    /** Last update timestamp */
    updatedAt!: Date;
    /** Expiration timestamp */
    expiresAt!: Date;
    /** Cart status */
    status!: CartStatus;

    [key: string]: any;

    constructor(data?: ICart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.organizationId = _data["organizationId"];
            this.eventId = _data["eventId"];
            this.userId = _data["userId"];
            this.sessionId = _data["sessionId"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CartItem.fromJS(item));
            }
            this.customer = _data["customer"];
            this.subtotal = _data["subtotal"];
            this.fees = _data["fees"];
            this.taxes = _data["taxes"];
            this.total = _data["total"];
            this.currency = _data["currency"];
            this.discountCode = _data["discountCode"];
            this.discountAmount = _data["discountAmount"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>null;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>null;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Cart {
        data = typeof data === 'object' ? data : {};
        let result = new Cart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        data["eventId"] = this.eventId;
        data["userId"] = this.userId;
        data["sessionId"] = this.sessionId;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["customer"] = this.customer;
        data["subtotal"] = this.subtotal;
        data["fees"] = this.fees;
        data["taxes"] = this.taxes;
        data["total"] = this.total;
        data["currency"] = this.currency;
        data["discountCode"] = this.discountCode;
        data["discountAmount"] = this.discountAmount;
        data["createdAt"] = this.createdAt && this.createdAt.toISOString();
        data["updatedAt"] = this.updatedAt && this.updatedAt.toISOString();
        data["expiresAt"] = this.expiresAt && this.expiresAt.toISOString();
        data["status"] = this.status;
        return data;
    }
}

export interface ICart {
    /** Unique identifier */
    id: string;
    /** Organization ID */
    organizationId: string;
    /** Event ID */
    eventId: string;
    /** User ID (optional for guest checkout) */
    userId?: string;
    /** Session ID for tracking anonymous carts */
    sessionId: string;
    /** Cart items */
    items: CartItem[];
    /** Customer information (JSON) */
    customer?: any;
    /** Subtotal amount */
    subtotal: number;
    /** Service fees amount */
    fees: number;
    /** Tax amount */
    taxes: number;
    /** Total amount */
    total: number;
    /** Currency */
    currency: string;
    /** Discount code (if applied) */
    discountCode?: string;
    /** Discount amount */
    discountAmount?: number;
    /** Creation timestamp */
    createdAt: Date;
    /** Last update timestamp */
    updatedAt: Date;
    /** Expiration timestamp */
    expiresAt: Date;
    /** Cart status */
    status: CartStatus;

    [key: string]: any;
}

export class AddCartItemDto implements IAddCartItemDto {
    /** Ticket type ID (for ticket items) */
    ticketTypeId?: string;
    /** Item name */
    name!: string;
    /** Quantity */
    quantity!: number;
    /** Unit price */
    unitPrice!: number;
    /** Item type */
    type!: AddCartItemDtoType;
    /** Additional metadata (JSON) */
    metadata?: any;

    [key: string]: any;

    constructor(data?: IAddCartItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.quantity = 1;
            this.type = AddCartItemDtoType.Ticket;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.ticketTypeId = _data["ticketTypeId"];
            this.name = _data["name"];
            this.quantity = _data["quantity"] !== undefined ? _data["quantity"] : 1;
            this.unitPrice = _data["unitPrice"];
            this.type = _data["type"] !== undefined ? _data["type"] : AddCartItemDtoType.Ticket;
            this.metadata = _data["metadata"];
        }
    }

    static fromJS(data: any): AddCartItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddCartItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["ticketTypeId"] = this.ticketTypeId;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["type"] = this.type;
        data["metadata"] = this.metadata;
        return data;
    }
}

export interface IAddCartItemDto {
    /** Ticket type ID (for ticket items) */
    ticketTypeId?: string;
    /** Item name */
    name: string;
    /** Quantity */
    quantity: number;
    /** Unit price */
    unitPrice: number;
    /** Item type */
    type: AddCartItemDtoType;
    /** Additional metadata (JSON) */
    metadata?: any;

    [key: string]: any;
}

export class UpdateCartItemDto implements IUpdateCartItemDto {
    /** Item name */
    name?: string;
    /** Quantity */
    quantity?: number;
    /** Unit price */
    unitPrice?: number;
    /** Item type */
    type?: UpdateCartItemDtoType;
    /** Additional metadata (JSON) */
    metadata?: any;

    [key: string]: any;

    constructor(data?: IUpdateCartItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.type = _data["type"];
            this.metadata = _data["metadata"];
        }
    }

    static fromJS(data: any): UpdateCartItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCartItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["type"] = this.type;
        data["metadata"] = this.metadata;
        return data;
    }
}

export interface IUpdateCartItemDto {
    /** Item name */
    name?: string;
    /** Quantity */
    quantity?: number;
    /** Unit price */
    unitPrice?: number;
    /** Item type */
    type?: UpdateCartItemDtoType;
    /** Additional metadata (JSON) */
    metadata?: any;

    [key: string]: any;
}

export class CreatePaymentIntentDto implements ICreatePaymentIntentDto {
    /** Organization ID */
    organizationId!: string;
    /** Amount to charge */
    amount!: number;
    /** Currency code */
    currency!: string;
    /** Additional metadata for the payment intent */
    metadata?: any;

    [key: string]: any;

    constructor(data?: ICreatePaymentIntentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.currency = "usd";
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.organizationId = _data["organizationId"];
            this.amount = _data["amount"];
            this.currency = _data["currency"] !== undefined ? _data["currency"] : "usd";
            this.metadata = _data["metadata"];
        }
    }

    static fromJS(data: any): CreatePaymentIntentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentIntentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["organizationId"] = this.organizationId;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["metadata"] = this.metadata;
        return data;
    }
}

export interface ICreatePaymentIntentDto {
    /** Organization ID */
    organizationId: string;
    /** Amount to charge */
    amount: number;
    /** Currency code */
    currency: string;
    /** Additional metadata for the payment intent */
    metadata?: any;

    [key: string]: any;
}

export class PaymentIntentResponseDto implements IPaymentIntentResponseDto {
    /** Client secret for the payment intent */
    clientSecret!: string;
    /** ID of the payment intent */
    paymentIntentId!: string;
    /** Name of the payment provider */
    providerName!: string;

    [key: string]: any;

    constructor(data?: IPaymentIntentResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.clientSecret = _data["clientSecret"];
            this.paymentIntentId = _data["paymentIntentId"];
            this.providerName = _data["providerName"];
        }
    }

    static fromJS(data: any): PaymentIntentResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIntentResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["clientSecret"] = this.clientSecret;
        data["paymentIntentId"] = this.paymentIntentId;
        data["providerName"] = this.providerName;
        return data;
    }
}

export interface IPaymentIntentResponseDto {
    /** Client secret for the payment intent */
    clientSecret: string;
    /** ID of the payment intent */
    paymentIntentId: string;
    /** Name of the payment provider */
    providerName: string;

    [key: string]: any;
}

export class ConfirmPaymentDto implements IConfirmPaymentDto {
    /** Organization ID */
    organizationId!: string;
    /** Payment intent ID */
    paymentIntentId!: string;

    [key: string]: any;

    constructor(data?: IConfirmPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.organizationId = _data["organizationId"];
            this.paymentIntentId = _data["paymentIntentId"];
        }
    }

    static fromJS(data: any): ConfirmPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["organizationId"] = this.organizationId;
        data["paymentIntentId"] = this.paymentIntentId;
        return data;
    }
}

export interface IConfirmPaymentDto {
    /** Organization ID */
    organizationId: string;
    /** Payment intent ID */
    paymentIntentId: string;

    [key: string]: any;
}

export class PaymentConfirmationResponseDto implements IPaymentConfirmationResponseDto {
    /** Status of the payment */
    status!: PaymentConfirmationResponseDtoStatus;
    /** Additional payment data from the provider */
    paymentData!: any;

    [key: string]: any;

    constructor(data?: IPaymentConfirmationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
            this.paymentData = _data["paymentData"];
        }
    }

    static fromJS(data: any): PaymentConfirmationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentConfirmationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        data["paymentData"] = this.paymentData;
        return data;
    }
}

export interface IPaymentConfirmationResponseDto {
    /** Status of the payment */
    status: PaymentConfirmationResponseDtoStatus;
    /** Additional payment data from the provider */
    paymentData: any;

    [key: string]: any;
}

export class ProcessRefundDto implements IProcessRefundDto {
    /** Organization ID */
    organizationId!: string;
    /** Payment intent ID */
    paymentIntentId!: string;
    /** Amount to refund (leave empty for full refund) */
    amount?: number;

    [key: string]: any;

    constructor(data?: IProcessRefundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.organizationId = _data["organizationId"];
            this.paymentIntentId = _data["paymentIntentId"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): ProcessRefundDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessRefundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["organizationId"] = this.organizationId;
        data["paymentIntentId"] = this.paymentIntentId;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IProcessRefundDto {
    /** Organization ID */
    organizationId: string;
    /** Payment intent ID */
    paymentIntentId: string;
    /** Amount to refund (leave empty for full refund) */
    amount?: number;

    [key: string]: any;
}

/** Transaction type */
export enum TransactionType {
    Purchase = "purchase",
    Refund = "refund",
    Chargeback = "chargeback",
    Payout = "payout",
}

/** Transaction status */
export enum TransactionStatus {
    Pending = "pending",
    Completed = "completed",
    Failed = "failed",
    Cancelled = "cancelled",
}

export class Transaction implements ITransaction {
    /** Unique identifier */
    id!: string;
    /** Organization ID */
    organizationId!: string;
    /** Order ID */
    orderId?: string;
    /** User ID (optional for guest checkout) */
    userId?: string;
    /** Transaction type */
    type!: TransactionType;
    /** Transaction amount */
    amount!: number;
    /** Currency */
    currency!: string;
    /** Payment method */
    paymentMethod!: string;
    /** Payment method ID from provider */
    paymentMethodId!: string;
    /** Payment intent ID from provider */
    paymentIntentId?: string;
    /** Transaction status */
    status!: TransactionStatus;
    /** Gateway fee */
    gatewayFee?: number;
    /** Platform fee */
    platformFee?: number;
    /** Additional metadata (JSON) */
    metadata?: any;
    /** Error message (if transaction failed) */
    errorMessage?: string;
    /** Creation timestamp */
    createdAt!: Date;
    /** Last update timestamp */
    updatedAt!: Date;

    [key: string]: any;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.organizationId = _data["organizationId"];
            this.orderId = _data["orderId"];
            this.userId = _data["userId"];
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.paymentMethod = _data["paymentMethod"];
            this.paymentMethodId = _data["paymentMethodId"];
            this.paymentIntentId = _data["paymentIntentId"];
            this.status = _data["status"];
            this.gatewayFee = _data["gatewayFee"];
            this.platformFee = _data["platformFee"];
            this.metadata = _data["metadata"];
            this.errorMessage = _data["errorMessage"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        data["orderId"] = this.orderId;
        data["userId"] = this.userId;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["paymentMethod"] = this.paymentMethod;
        data["paymentMethodId"] = this.paymentMethodId;
        data["paymentIntentId"] = this.paymentIntentId;
        data["status"] = this.status;
        data["gatewayFee"] = this.gatewayFee;
        data["platformFee"] = this.platformFee;
        data["metadata"] = this.metadata;
        data["errorMessage"] = this.errorMessage;
        data["createdAt"] = this.createdAt && this.createdAt.toISOString();
        data["updatedAt"] = this.updatedAt && this.updatedAt.toISOString();
        return data;
    }
}

export interface ITransaction {
    /** Unique identifier */
    id: string;
    /** Organization ID */
    organizationId: string;
    /** Order ID */
    orderId?: string;
    /** User ID (optional for guest checkout) */
    userId?: string;
    /** Transaction type */
    type: TransactionType;
    /** Transaction amount */
    amount: number;
    /** Currency */
    currency: string;
    /** Payment method */
    paymentMethod: string;
    /** Payment method ID from provider */
    paymentMethodId: string;
    /** Payment intent ID from provider */
    paymentIntentId?: string;
    /** Transaction status */
    status: TransactionStatus;
    /** Gateway fee */
    gatewayFee?: number;
    /** Platform fee */
    platformFee?: number;
    /** Additional metadata (JSON) */
    metadata?: any;
    /** Error message (if transaction failed) */
    errorMessage?: string;
    /** Creation timestamp */
    createdAt: Date;
    /** Last update timestamp */
    updatedAt: Date;

    [key: string]: any;
}

export class CreatePluginDto implements ICreatePluginDto {
    /** Plugin name */
    name!: string;
    /** Plugin version */
    version!: string;
    /** Plugin description */
    description!: string;
    /** Plugin category */
    category!: CreatePluginDtoCategory;
    /** URL to the plugin bundle */
    bundleUrl!: string;
    /** List of extension points this plugin implements */
    extensionPoints!: string[];
    /** Admin components provided by the plugin */
    adminComponents!: any;
    /** Storefront components provided by the plugin */
    storefrontComponents!: any;
    /** Metadata about the plugin */
    metadata!: any;
    /** Required permissions for this plugin */
    requiredPermissions?: string[];

    [key: string]: any;

    constructor(data?: ICreatePluginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.extensionPoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.bundleUrl = _data["bundleUrl"];
            if (Array.isArray(_data["extensionPoints"])) {
                this.extensionPoints = [] as any;
                for (let item of _data["extensionPoints"])
                    this.extensionPoints!.push(item);
            }
            this.adminComponents = _data["adminComponents"];
            this.storefrontComponents = _data["storefrontComponents"];
            this.metadata = _data["metadata"];
            if (Array.isArray(_data["requiredPermissions"])) {
                this.requiredPermissions = [] as any;
                for (let item of _data["requiredPermissions"])
                    this.requiredPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreatePluginDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePluginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["version"] = this.version;
        data["description"] = this.description;
        data["category"] = this.category;
        data["bundleUrl"] = this.bundleUrl;
        if (Array.isArray(this.extensionPoints)) {
            data["extensionPoints"] = [];
            for (let item of this.extensionPoints)
                data["extensionPoints"].push(item);
        }
        data["adminComponents"] = this.adminComponents;
        data["storefrontComponents"] = this.storefrontComponents;
        data["metadata"] = this.metadata;
        if (Array.isArray(this.requiredPermissions)) {
            data["requiredPermissions"] = [];
            for (let item of this.requiredPermissions)
                data["requiredPermissions"].push(item);
        }
        return data;
    }
}

export interface ICreatePluginDto {
    /** Plugin name */
    name: string;
    /** Plugin version */
    version: string;
    /** Plugin description */
    description: string;
    /** Plugin category */
    category: CreatePluginDtoCategory;
    /** URL to the plugin bundle */
    bundleUrl: string;
    /** List of extension points this plugin implements */
    extensionPoints: string[];
    /** Admin components provided by the plugin */
    adminComponents: any;
    /** Storefront components provided by the plugin */
    storefrontComponents: any;
    /** Metadata about the plugin */
    metadata: any;
    /** Required permissions for this plugin */
    requiredPermissions?: string[];

    [key: string]: any;
}

/** Plugin category */
export enum PluginCategory {
    Payment = "payment",
    Notification = "notification",
    Analytics = "analytics",
    Integration = "integration",
    Ui = "ui",
    Workflow = "workflow",
}

/** Plugin status */
export enum PluginStatus {
    Active = "active",
    Inactive = "inactive",
    Deprecated = "deprecated",
    Removed = "removed",
}

export class PluginResponseDto implements IPluginResponseDto {
    /** Unique identifier */
    id!: string;
    /** Plugin name */
    name!: string;
    /** Plugin version */
    version!: string;
    /** Plugin description */
    description!: string;
    /** Plugin category */
    category!: PluginCategory;
    /** Plugin status */
    status!: PluginStatus;
    /** URL to the plugin bundle */
    bundleUrl?: string;
    /** List of extension points this plugin implements */
    extensionPoints!: string[];
    /** Required permissions for this plugin */
    requiredPermissions!: string[];
    /** Metadata about the plugin */
    metadata?: any;
    /** Creation timestamp */
    createdAt!: Date;
    /** Last update timestamp */
    updatedAt!: Date;

    [key: string]: any;

    constructor(data?: IPluginResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.extensionPoints = [];
            this.requiredPermissions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.status = _data["status"];
            this.bundleUrl = _data["bundleUrl"];
            if (Array.isArray(_data["extensionPoints"])) {
                this.extensionPoints = [] as any;
                for (let item of _data["extensionPoints"])
                    this.extensionPoints!.push(item);
            }
            if (Array.isArray(_data["requiredPermissions"])) {
                this.requiredPermissions = [] as any;
                for (let item of _data["requiredPermissions"])
                    this.requiredPermissions!.push(item);
            }
            this.metadata = _data["metadata"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PluginResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new PluginResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["version"] = this.version;
        data["description"] = this.description;
        data["category"] = this.category;
        data["status"] = this.status;
        data["bundleUrl"] = this.bundleUrl;
        if (Array.isArray(this.extensionPoints)) {
            data["extensionPoints"] = [];
            for (let item of this.extensionPoints)
                data["extensionPoints"].push(item);
        }
        if (Array.isArray(this.requiredPermissions)) {
            data["requiredPermissions"] = [];
            for (let item of this.requiredPermissions)
                data["requiredPermissions"].push(item);
        }
        data["metadata"] = this.metadata;
        data["createdAt"] = this.createdAt && this.createdAt.toISOString();
        data["updatedAt"] = this.updatedAt && this.updatedAt.toISOString();
        return data;
    }
}

export interface IPluginResponseDto {
    /** Unique identifier */
    id: string;
    /** Plugin name */
    name: string;
    /** Plugin version */
    version: string;
    /** Plugin description */
    description: string;
    /** Plugin category */
    category: PluginCategory;
    /** Plugin status */
    status: PluginStatus;
    /** URL to the plugin bundle */
    bundleUrl?: string;
    /** List of extension points this plugin implements */
    extensionPoints: string[];
    /** Required permissions for this plugin */
    requiredPermissions: string[];
    /** Metadata about the plugin */
    metadata?: any;
    /** Creation timestamp */
    createdAt: Date;
    /** Last update timestamp */
    updatedAt: Date;

    [key: string]: any;
}

export class RegisterPaymentPluginDto implements IRegisterPaymentPluginDto {
    /** Plugin name */
    name!: string;
    /** Plugin version */
    version!: string;
    /** Plugin description */
    description!: string;
    /** Plugin category */
    category!: RegisterPaymentPluginDtoCategory;
    /** URL to the plugin bundle */
    bundleUrl!: string;
    /** List of extension points this plugin implements */
    extensionPoints!: string[];
    /** Admin components provided by the plugin */
    adminComponents!: any;
    /** Storefront components provided by the plugin */
    storefrontComponents!: any;
    /** Metadata about the plugin */
    metadata!: any;
    /** Required permissions for this plugin */
    requiredPermissions?: string[];
    /** Payment provider name */
    provider!: RegisterPaymentPluginDtoProvider;
    /** Supported payment methods */
    supportedMethods!: string[];
    /** Supported currencies */
    supportedCurrencies!: string[];
    /** Gateway-specific configuration schema */
    configurationSchema!: any;
    /** Default plugin configuration */
    defaultConfiguration?: any;

    [key: string]: any;

    constructor(data?: IRegisterPaymentPluginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.extensionPoints = [];
            this.supportedMethods = [];
            this.supportedCurrencies = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.bundleUrl = _data["bundleUrl"];
            if (Array.isArray(_data["extensionPoints"])) {
                this.extensionPoints = [] as any;
                for (let item of _data["extensionPoints"])
                    this.extensionPoints!.push(item);
            }
            this.adminComponents = _data["adminComponents"];
            this.storefrontComponents = _data["storefrontComponents"];
            this.metadata = _data["metadata"];
            if (Array.isArray(_data["requiredPermissions"])) {
                this.requiredPermissions = [] as any;
                for (let item of _data["requiredPermissions"])
                    this.requiredPermissions!.push(item);
            }
            this.provider = _data["provider"];
            if (Array.isArray(_data["supportedMethods"])) {
                this.supportedMethods = [] as any;
                for (let item of _data["supportedMethods"])
                    this.supportedMethods!.push(item);
            }
            if (Array.isArray(_data["supportedCurrencies"])) {
                this.supportedCurrencies = [] as any;
                for (let item of _data["supportedCurrencies"])
                    this.supportedCurrencies!.push(item);
            }
            this.configurationSchema = _data["configurationSchema"];
            this.defaultConfiguration = _data["defaultConfiguration"];
        }
    }

    static fromJS(data: any): RegisterPaymentPluginDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterPaymentPluginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["version"] = this.version;
        data["description"] = this.description;
        data["category"] = this.category;
        data["bundleUrl"] = this.bundleUrl;
        if (Array.isArray(this.extensionPoints)) {
            data["extensionPoints"] = [];
            for (let item of this.extensionPoints)
                data["extensionPoints"].push(item);
        }
        data["adminComponents"] = this.adminComponents;
        data["storefrontComponents"] = this.storefrontComponents;
        data["metadata"] = this.metadata;
        if (Array.isArray(this.requiredPermissions)) {
            data["requiredPermissions"] = [];
            for (let item of this.requiredPermissions)
                data["requiredPermissions"].push(item);
        }
        data["provider"] = this.provider;
        if (Array.isArray(this.supportedMethods)) {
            data["supportedMethods"] = [];
            for (let item of this.supportedMethods)
                data["supportedMethods"].push(item);
        }
        if (Array.isArray(this.supportedCurrencies)) {
            data["supportedCurrencies"] = [];
            for (let item of this.supportedCurrencies)
                data["supportedCurrencies"].push(item);
        }
        data["configurationSchema"] = this.configurationSchema;
        data["defaultConfiguration"] = this.defaultConfiguration;
        return data;
    }
}

export interface IRegisterPaymentPluginDto {
    /** Plugin name */
    name: string;
    /** Plugin version */
    version: string;
    /** Plugin description */
    description: string;
    /** Plugin category */
    category: RegisterPaymentPluginDtoCategory;
    /** URL to the plugin bundle */
    bundleUrl: string;
    /** List of extension points this plugin implements */
    extensionPoints: string[];
    /** Admin components provided by the plugin */
    adminComponents: any;
    /** Storefront components provided by the plugin */
    storefrontComponents: any;
    /** Metadata about the plugin */
    metadata: any;
    /** Required permissions for this plugin */
    requiredPermissions?: string[];
    /** Payment provider name */
    provider: RegisterPaymentPluginDtoProvider;
    /** Supported payment methods */
    supportedMethods: string[];
    /** Supported currencies */
    supportedCurrencies: string[];
    /** Gateway-specific configuration schema */
    configurationSchema: any;
    /** Default plugin configuration */
    defaultConfiguration?: any;

    [key: string]: any;
}

export class UpdatePluginDto implements IUpdatePluginDto {
    /** Plugin name */
    name?: string;
    /** Plugin version */
    version?: string;
    /** Plugin description */
    description?: string;
    /** Plugin category */
    category?: UpdatePluginDtoCategory;
    /** URL to the plugin bundle */
    bundleUrl?: string;
    /** List of extension points this plugin implements */
    extensionPoints?: string[];
    /** Admin components provided by the plugin */
    adminComponents?: any;
    /** Storefront components provided by the plugin */
    storefrontComponents?: any;
    /** Metadata about the plugin */
    metadata?: any;
    /** Required permissions for this plugin */
    requiredPermissions?: string[];

    [key: string]: any;

    constructor(data?: IUpdatePluginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.bundleUrl = _data["bundleUrl"];
            if (Array.isArray(_data["extensionPoints"])) {
                this.extensionPoints = [] as any;
                for (let item of _data["extensionPoints"])
                    this.extensionPoints!.push(item);
            }
            this.adminComponents = _data["adminComponents"];
            this.storefrontComponents = _data["storefrontComponents"];
            this.metadata = _data["metadata"];
            if (Array.isArray(_data["requiredPermissions"])) {
                this.requiredPermissions = [] as any;
                for (let item of _data["requiredPermissions"])
                    this.requiredPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdatePluginDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePluginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["version"] = this.version;
        data["description"] = this.description;
        data["category"] = this.category;
        data["bundleUrl"] = this.bundleUrl;
        if (Array.isArray(this.extensionPoints)) {
            data["extensionPoints"] = [];
            for (let item of this.extensionPoints)
                data["extensionPoints"].push(item);
        }
        data["adminComponents"] = this.adminComponents;
        data["storefrontComponents"] = this.storefrontComponents;
        data["metadata"] = this.metadata;
        if (Array.isArray(this.requiredPermissions)) {
            data["requiredPermissions"] = [];
            for (let item of this.requiredPermissions)
                data["requiredPermissions"].push(item);
        }
        return data;
    }
}

export interface IUpdatePluginDto {
    /** Plugin name */
    name?: string;
    /** Plugin version */
    version?: string;
    /** Plugin description */
    description?: string;
    /** Plugin category */
    category?: UpdatePluginDtoCategory;
    /** URL to the plugin bundle */
    bundleUrl?: string;
    /** List of extension points this plugin implements */
    extensionPoints?: string[];
    /** Admin components provided by the plugin */
    adminComponents?: any;
    /** Storefront components provided by the plugin */
    storefrontComponents?: any;
    /** Metadata about the plugin */
    metadata?: any;
    /** Required permissions for this plugin */
    requiredPermissions?: string[];

    [key: string]: any;
}

export class SimpleInstallPluginDto implements ISimpleInstallPluginDto {
    /** Plugin ID to install */
    pluginId!: string;

    [key: string]: any;

    constructor(data?: ISimpleInstallPluginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.pluginId = _data["pluginId"];
        }
    }

    static fromJS(data: any): SimpleInstallPluginDto {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleInstallPluginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["pluginId"] = this.pluginId;
        return data;
    }
}

export interface ISimpleInstallPluginDto {
    /** Plugin ID to install */
    pluginId: string;

    [key: string]: any;
}

export class InstalledPluginDto implements IInstalledPluginDto {
    /** Unique identifier for the installed plugin */
    id!: string;
    /** Plugin ID reference */
    pluginId!: string;
    /** Organization ID that installed the plugin */
    organizationId!: string;
    /** Plugin name */
    name!: string;
    /** Plugin version */
    version!: string;
    /** Plugin description */
    description!: string;
    /** Plugin category */
    category!: InstalledPluginDtoCategory;
    /** Plugin status */
    status!: InstalledPluginDtoStatus;
    /** Whether the plugin is enabled */
    enabled!: boolean;
    /** Plugin configuration */
    configuration!: any;
    /** Installation date */
    installedAt!: Date;
    /** Last update date */
    updatedAt!: Date;
    /** Plugin metadata */
    metadata!: any;

    [key: string]: any;

    constructor(data?: IInstalledPluginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.pluginId = _data["pluginId"];
            this.organizationId = _data["organizationId"];
            this.name = _data["name"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.status = _data["status"];
            this.enabled = _data["enabled"];
            this.configuration = _data["configuration"];
            this.installedAt = _data["installedAt"] ? new Date(_data["installedAt"].toString()) : <any>null;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>null;
            this.metadata = _data["metadata"];
        }
    }

    static fromJS(data: any): InstalledPluginDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstalledPluginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["pluginId"] = this.pluginId;
        data["organizationId"] = this.organizationId;
        data["name"] = this.name;
        data["version"] = this.version;
        data["description"] = this.description;
        data["category"] = this.category;
        data["status"] = this.status;
        data["enabled"] = this.enabled;
        data["configuration"] = this.configuration;
        data["installedAt"] = this.installedAt && this.installedAt.toISOString();
        data["updatedAt"] = this.updatedAt && this.updatedAt.toISOString();
        data["metadata"] = this.metadata;
        return data;
    }
}

export interface IInstalledPluginDto {
    /** Unique identifier for the installed plugin */
    id: string;
    /** Plugin ID reference */
    pluginId: string;
    /** Organization ID that installed the plugin */
    organizationId: string;
    /** Plugin name */
    name: string;
    /** Plugin version */
    version: string;
    /** Plugin description */
    description: string;
    /** Plugin category */
    category: InstalledPluginDtoCategory;
    /** Plugin status */
    status: InstalledPluginDtoStatus;
    /** Whether the plugin is enabled */
    enabled: boolean;
    /** Plugin configuration */
    configuration: any;
    /** Installation date */
    installedAt: Date;
    /** Last update date */
    updatedAt: Date;
    /** Plugin metadata */
    metadata: any;

    [key: string]: any;
}

export class AudienceAnalyticsDto implements IAudienceAnalyticsDto {
    /** Total number of unique visitors */
    totalVisitors!: number;
    /** Age distribution of visitors */
    ageDistribution!: { [key: string]: number; };
    /** Gender distribution of visitors */
    genderDistribution!: { [key: string]: number; };
    /** Geographic distribution of visitors */
    geographicDistribution!: { [key: string]: number; };
    /** Device types used by visitors */
    deviceDistribution!: { [key: string]: number; };
    /** Visitor engagement metrics */
    engagement!: Engagement;

    [key: string]: any;

    constructor(data?: IAudienceAnalyticsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ageDistribution = {};
            this.genderDistribution = {};
            this.geographicDistribution = {};
            this.deviceDistribution = {};
            this.engagement = new Engagement();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.totalVisitors = _data["totalVisitors"];
            if (_data["ageDistribution"]) {
                this.ageDistribution = {} as any;
                for (let key in _data["ageDistribution"]) {
                    if (_data["ageDistribution"].hasOwnProperty(key))
                        (<any>this.ageDistribution)![key] = _data["ageDistribution"][key];
                }
            }
            if (_data["genderDistribution"]) {
                this.genderDistribution = {} as any;
                for (let key in _data["genderDistribution"]) {
                    if (_data["genderDistribution"].hasOwnProperty(key))
                        (<any>this.genderDistribution)![key] = _data["genderDistribution"][key];
                }
            }
            if (_data["geographicDistribution"]) {
                this.geographicDistribution = {} as any;
                for (let key in _data["geographicDistribution"]) {
                    if (_data["geographicDistribution"].hasOwnProperty(key))
                        (<any>this.geographicDistribution)![key] = _data["geographicDistribution"][key];
                }
            }
            if (_data["deviceDistribution"]) {
                this.deviceDistribution = {} as any;
                for (let key in _data["deviceDistribution"]) {
                    if (_data["deviceDistribution"].hasOwnProperty(key))
                        (<any>this.deviceDistribution)![key] = _data["deviceDistribution"][key];
                }
            }
            this.engagement = _data["engagement"] ? Engagement.fromJS(_data["engagement"]) : new Engagement();
        }
    }

    static fromJS(data: any): AudienceAnalyticsDto {
        data = typeof data === 'object' ? data : {};
        let result = new AudienceAnalyticsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["totalVisitors"] = this.totalVisitors;
        if (this.ageDistribution) {
            data["ageDistribution"] = {};
            for (let key in this.ageDistribution) {
                if (this.ageDistribution.hasOwnProperty(key))
                    (<any>data["ageDistribution"])[key] = (<any>this.ageDistribution)[key];
            }
        }
        if (this.genderDistribution) {
            data["genderDistribution"] = {};
            for (let key in this.genderDistribution) {
                if (this.genderDistribution.hasOwnProperty(key))
                    (<any>data["genderDistribution"])[key] = (<any>this.genderDistribution)[key];
            }
        }
        if (this.geographicDistribution) {
            data["geographicDistribution"] = {};
            for (let key in this.geographicDistribution) {
                if (this.geographicDistribution.hasOwnProperty(key))
                    (<any>data["geographicDistribution"])[key] = (<any>this.geographicDistribution)[key];
            }
        }
        if (this.deviceDistribution) {
            data["deviceDistribution"] = {};
            for (let key in this.deviceDistribution) {
                if (this.deviceDistribution.hasOwnProperty(key))
                    (<any>data["deviceDistribution"])[key] = (<any>this.deviceDistribution)[key];
            }
        }
        data["engagement"] = this.engagement ? this.engagement.toJSON() : this.engagement;
        return data;
    }
}

export interface IAudienceAnalyticsDto {
    /** Total number of unique visitors */
    totalVisitors: number;
    /** Age distribution of visitors */
    ageDistribution: { [key: string]: number; };
    /** Gender distribution of visitors */
    genderDistribution: { [key: string]: number; };
    /** Geographic distribution of visitors */
    geographicDistribution: { [key: string]: number; };
    /** Device types used by visitors */
    deviceDistribution: { [key: string]: number; };
    /** Visitor engagement metrics */
    engagement: Engagement;

    [key: string]: any;
}

export class EventAnalytics implements IEventAnalytics {
    /** Unique identifier */
    id!: string;
    /** Event ID */
    eventId!: string;
    /** Organization ID */
    organizationId!: string;
    /** Date of analytics data */
    date!: Date;
    /** Total page views */
    totalViews!: number;
    /** Unique page views */
    uniqueViews!: number;
    /** Total sales count */
    totalSales!: number;
    /** Number of tickets sold */
    ticketsSold!: number;
    /** Conversion rate (percentage) */
    conversionRate!: number;
    /** Total revenue */
    revenue!: number;
    /** Breakdown of ticket types sold */
    ticketTypeBreakdown!: any;
    /** Number of refunds */
    refunds!: number;
    /** Traffic referrers */
    referrers!: any;
    /** Creation/Update timestamp */
    createdAt!: Date;

    [key: string]: any;

    constructor(data?: IEventAnalytics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.eventId = _data["eventId"];
            this.organizationId = _data["organizationId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.totalViews = _data["totalViews"];
            this.uniqueViews = _data["uniqueViews"];
            this.totalSales = _data["totalSales"];
            this.ticketsSold = _data["ticketsSold"];
            this.conversionRate = _data["conversionRate"];
            this.revenue = _data["revenue"];
            this.ticketTypeBreakdown = _data["ticketTypeBreakdown"];
            this.refunds = _data["refunds"];
            this.referrers = _data["referrers"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): EventAnalytics {
        data = typeof data === 'object' ? data : {};
        let result = new EventAnalytics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["eventId"] = this.eventId;
        data["organizationId"] = this.organizationId;
        data["date"] = this.date && this.date.toISOString();
        data["totalViews"] = this.totalViews;
        data["uniqueViews"] = this.uniqueViews;
        data["totalSales"] = this.totalSales;
        data["ticketsSold"] = this.ticketsSold;
        data["conversionRate"] = this.conversionRate;
        data["revenue"] = this.revenue;
        data["ticketTypeBreakdown"] = this.ticketTypeBreakdown;
        data["refunds"] = this.refunds;
        data["referrers"] = this.referrers;
        data["createdAt"] = this.createdAt && this.createdAt.toISOString();
        return data;
    }
}

export interface IEventAnalytics {
    /** Unique identifier */
    id: string;
    /** Event ID */
    eventId: string;
    /** Organization ID */
    organizationId: string;
    /** Date of analytics data */
    date: Date;
    /** Total page views */
    totalViews: number;
    /** Unique page views */
    uniqueViews: number;
    /** Total sales count */
    totalSales: number;
    /** Number of tickets sold */
    ticketsSold: number;
    /** Conversion rate (percentage) */
    conversionRate: number;
    /** Total revenue */
    revenue: number;
    /** Breakdown of ticket types sold */
    ticketTypeBreakdown: any;
    /** Number of refunds */
    refunds: number;
    /** Traffic referrers */
    referrers: any;
    /** Creation/Update timestamp */
    createdAt: Date;

    [key: string]: any;
}

/** Date range type */
export enum DateRangeType {
    Daily = "daily",
    Weekly = "weekly",
    Monthly = "monthly",
}

export class SalesAnalytics implements ISalesAnalytics {
    /** Unique identifier */
    id!: string;
    /** Organization ID */
    organizationId!: string;
    /** Date range type */
    dateRange!: DateRangeType;
    /** Date of analytics data */
    date!: Date;
    /** Total sales count */
    totalSales!: number;
    /** Total revenue */
    totalRevenue!: number;
    /** Total tickets sold */
    ticketsSold!: number;
    /** Average order value */
    averageOrderValue!: number;
    /** Refund amount */
    refundAmount!: number;
    /** Service fees collected */
    feesCollected!: number;
    /** Breakdown by event */
    eventBreakdown!: any;
    /** Breakdown by payment method */
    paymentMethodBreakdown!: any;
    /** Creation/Update timestamp */
    createdAt!: Date;

    [key: string]: any;

    constructor(data?: ISalesAnalytics) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.organizationId = _data["organizationId"];
            this.dateRange = _data["dateRange"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.totalSales = _data["totalSales"];
            this.totalRevenue = _data["totalRevenue"];
            this.ticketsSold = _data["ticketsSold"];
            this.averageOrderValue = _data["averageOrderValue"];
            this.refundAmount = _data["refundAmount"];
            this.feesCollected = _data["feesCollected"];
            this.eventBreakdown = _data["eventBreakdown"];
            this.paymentMethodBreakdown = _data["paymentMethodBreakdown"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): SalesAnalytics {
        data = typeof data === 'object' ? data : {};
        let result = new SalesAnalytics();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["organizationId"] = this.organizationId;
        data["dateRange"] = this.dateRange;
        data["date"] = this.date && this.date.toISOString();
        data["totalSales"] = this.totalSales;
        data["totalRevenue"] = this.totalRevenue;
        data["ticketsSold"] = this.ticketsSold;
        data["averageOrderValue"] = this.averageOrderValue;
        data["refundAmount"] = this.refundAmount;
        data["feesCollected"] = this.feesCollected;
        data["eventBreakdown"] = this.eventBreakdown;
        data["paymentMethodBreakdown"] = this.paymentMethodBreakdown;
        data["createdAt"] = this.createdAt && this.createdAt.toISOString();
        return data;
    }
}

export interface ISalesAnalytics {
    /** Unique identifier */
    id: string;
    /** Organization ID */
    organizationId: string;
    /** Date range type */
    dateRange: DateRangeType;
    /** Date of analytics data */
    date: Date;
    /** Total sales count */
    totalSales: number;
    /** Total revenue */
    totalRevenue: number;
    /** Total tickets sold */
    ticketsSold: number;
    /** Average order value */
    averageOrderValue: number;
    /** Refund amount */
    refundAmount: number;
    /** Service fees collected */
    feesCollected: number;
    /** Breakdown by event */
    eventBreakdown: any;
    /** Breakdown by payment method */
    paymentMethodBreakdown: any;
    /** Creation/Update timestamp */
    createdAt: Date;

    [key: string]: any;
}

export enum Status {
    Draft = "draft",
    Published = "published",
    Cancelled = "cancelled",
    Completed = "completed",
}

export enum Status2 {
    Active = "active",
    Inactive = "inactive",
    Deprecated = "deprecated",
    Removed = "removed",
}

export class Body implements IBody {
    /** Plugin ID */
    id!: string;
    /** Plugin name */
    name!: string;
    /** Plugin version */
    version!: string;
    /** Plugin description */
    description!: string;
    /** Plugin category */
    category!: string;
    /** Plugin source code */
    sourceCode!: string;
    /** URL to the plugin bundle */
    bundleUrl!: string;
    /** Required permissions */
    requiredPermissions?: string[];

    [key: string]: any;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.version = _data["version"];
            this.description = _data["description"];
            this.category = _data["category"];
            this.sourceCode = _data["sourceCode"];
            this.bundleUrl = _data["bundleUrl"];
            if (Array.isArray(_data["requiredPermissions"])) {
                this.requiredPermissions = [] as any;
                for (let item of _data["requiredPermissions"])
                    this.requiredPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["version"] = this.version;
        data["description"] = this.description;
        data["category"] = this.category;
        data["sourceCode"] = this.sourceCode;
        data["bundleUrl"] = this.bundleUrl;
        if (Array.isArray(this.requiredPermissions)) {
            data["requiredPermissions"] = [];
            for (let item of this.requiredPermissions)
                data["requiredPermissions"].push(item);
        }
        return data;
    }
}

export interface IBody {
    /** Plugin ID */
    id: string;
    /** Plugin name */
    name: string;
    /** Plugin version */
    version: string;
    /** Plugin description */
    description: string;
    /** Plugin category */
    category: string;
    /** Plugin source code */
    sourceCode: string;
    /** URL to the plugin bundle */
    bundleUrl: string;
    /** Required permissions */
    requiredPermissions?: string[];

    [key: string]: any;
}

export enum Granularity {
    Daily = "daily",
    Weekly = "weekly",
    Monthly = "monthly",
}

export enum Type {
    FINANCIAL = "FINANCIAL",
    EVENT_MANAGEMENT = "EVENT_MANAGEMENT",
    USER_MANAGEMENT = "USER_MANAGEMENT",
    ADMINISTRATIVE = "ADMINISTRATIVE",
    SECURITY = "SECURITY",
    MARKETING = "MARKETING",
}

export enum Severity {
    LOW = "LOW",
    MEDIUM = "MEDIUM",
    HIGH = "HIGH",
}

export class Anonymous implements IAnonymous {
    id?: string;
    status?: string;
    amount?: number;

    [key: string]: any;

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.status = _data["status"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["status"] = this.status;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IAnonymous {
    id?: string;
    status?: string;
    amount?: number;

    [key: string]: any;
}

export class Anonymous2 implements IAnonymous2 {
    /** URL to the stored bundle */
    bundleUrl?: string;
    /** Plugin ID used for storage */
    pluginId?: string;
    /** Version used for storage */
    version?: string;

    [key: string]: any;

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.bundleUrl = _data["bundleUrl"];
            this.pluginId = _data["pluginId"];
            this.version = _data["version"];
        }
    }

    static fromJS(data: any): Anonymous2 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["bundleUrl"] = this.bundleUrl;
        data["pluginId"] = this.pluginId;
        data["version"] = this.version;
        return data;
    }
}

export interface IAnonymous2 {
    /** URL to the stored bundle */
    bundleUrl?: string;
    /** Plugin ID used for storage */
    pluginId?: string;
    /** Version used for storage */
    version?: string;

    [key: string]: any;
}

export enum DepartmentCustomFieldDtoType {
    Text = "text",
    Number = "number",
    Date = "date",
    Boolean = "boolean",
    Select = "select",
}

export enum OrganizationPlan {
    Free = "free",
    Basic = "basic",
    Pro = "pro",
    Enterprise = "enterprise",
}

export enum UserRole {
    Owner = "owner",
    Admin = "admin",
    Manager = "manager",
    Support = "support",
    Analyst = "analyst",
}

export enum UserStatus {
    Active = "active",
    Inactive = "inactive",
    Pending = "pending",
}

export enum EventResponseDtoLocationType {
    Physical = "physical",
    Virtual = "virtual",
    Hybrid = "hybrid",
}

export enum EventResponseDtoStatus {
    Draft = "draft",
    Published = "published",
    Cancelled = "cancelled",
    Completed = "completed",
}

export enum EventResponseDtoVisibility {
    Public = "public",
    Private = "private",
    Unlisted = "unlisted",
}

export enum AddCartItemDtoType {
    Ticket = "ticket",
    Merchandise = "merchandise",
    Fee = "fee",
}

export enum UpdateCartItemDtoType {
    Ticket = "ticket",
    Merchandise = "merchandise",
    Fee = "fee",
}

export enum PaymentConfirmationResponseDtoStatus {
    Succeeded = "succeeded",
    Processing = "processing",
    Requires_payment_method = "requires_payment_method",
    Requires_confirmation = "requires_confirmation",
    Canceled = "canceled",
}

export enum CreatePluginDtoCategory {
    Payment = "payment",
    Marketing = "marketing",
    Analytics = "analytics",
    Social = "social",
    Ticketing = "ticketing",
    Layout = "layout",
    Seating = "seating",
}

export enum RegisterPaymentPluginDtoCategory {
    Payment = "payment",
    Marketing = "marketing",
    Analytics = "analytics",
    Social = "social",
    Ticketing = "ticketing",
    Layout = "layout",
    Seating = "seating",
}

export enum RegisterPaymentPluginDtoProvider {
    Stripe = "stripe",
    Paypal = "paypal",
    Authorize_net = "authorize_net",
    Square = "square",
    Braintree = "braintree",
}

export enum UpdatePluginDtoCategory {
    Payment = "payment",
    Marketing = "marketing",
    Analytics = "analytics",
    Social = "social",
    Ticketing = "ticketing",
    Layout = "layout",
    Seating = "seating",
}

export enum InstalledPluginDtoCategory {
    Payment = "payment",
    Notification = "notification",
    Analytics = "analytics",
    Integration = "integration",
    Ui = "ui",
    Workflow = "workflow",
}

export enum InstalledPluginDtoStatus {
    Active = "active",
    Inactive = "inactive",
    Deprecated = "deprecated",
    Removed = "removed",
}

export class Engagement implements IEngagement {
    averageSessionDuration?: number;
    bounceRate?: number;
    returningVisitors?: number;

    [key: string]: any;

    constructor(data?: IEngagement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.averageSessionDuration = _data["averageSessionDuration"];
            this.bounceRate = _data["bounceRate"];
            this.returningVisitors = _data["returningVisitors"];
        }
    }

    static fromJS(data: any): Engagement {
        data = typeof data === 'object' ? data : {};
        let result = new Engagement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["averageSessionDuration"] = this.averageSessionDuration;
        data["bounceRate"] = this.bounceRate;
        data["returningVisitors"] = this.returningVisitors;
        return data;
    }
}

export interface IEngagement {
    averageSessionDuration?: number;
    bounceRate?: number;
    returningVisitors?: number;

    [key: string]: any;
}
//-----/CustomTypes.File-----

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

export function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

export function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

//-----/Types.File-----

import { addResultTypeFactory } from './api-client/helpers';
export { setBaseUrl, getBaseUrl } from './api-client/helpers';
export { setAxiosFactory, getAxios } from './api-client/helpers';


//-----PersistorHydrator.File-----
import type { PersistedClient } from '@tanstack/react-query-persist-client';
import type { DehydratedState, QueryKey } from '@tanstack/react-query'
import { getResultTypeFactory } from './api-client/helpers';

/*
 * If you have Dates in QueryKeys (i.e. in request parameters), you need to deserialize them to Dates correctly
 * (otherwise they are deserialized as strings by default, and your queries are broken).
 */
export function deserializeDate(str: unknown) {
  if (!str || typeof str !== 'string') return str;
  if (!/^\d\d\d\d\-\d\d\-\d\d/.test(str)) return str;
  
  const date = new Date(str);
  const isDate = date instanceof Date && !isNaN(date as any);
  
  return isDate ? date : str;
}

export function deserializeDatesInQueryKeys(queryKey: QueryKey) {
  return queryKey
    // We need to replace `null` with `undefined` in query key, because
    // `undefined` is serialized as `null`.
    // And most probably if we have `null` in QueryKey it actually means `undefined`.
    // We can't keep nulls, because they have a different meaning, and e.g. boolean parameters are not allowed to be null.
    .map(x => (x === null ? undefined : x))
    .map(x => deserializeDate(x));
}

export function deserializeClassesInQueryData(queryKey: QueryKey, data: any) {
  if (!data) {
    return data;
  } else if (typeof data !== 'object') {
    return data;
  } else if ('pages' in data && 'pageParams' in data && Array.isArray(data.pages) && Array.isArray(data.pageParams)) {
    // infinite query
    data.pages = data.pages.map((page:any) => deserializeClassesInQueryData(queryKey, page));
  } else if (Array.isArray(data)) {
    return data.map(elem => constructDtoClass(queryKey, elem));
  } else {
    return constructDtoClass(queryKey, data);
  }
}

/*
 * Pass this function as `deserialize` option to createSyncStoragePersister/createAsyncStoragePersister
 * to correctly deserialize your DTOs (including Dates)
 */
export function persisterDeserialize(cache: string): PersistedClient {
  const client: PersistedClient = JSON.parse(cache);
  client.clientState.queries.forEach((query) => {
    query.state.data = deserializeClassesInQueryData(query.queryKey, query.state.data);
    query.queryKey = deserializeDatesInQueryKeys(query.queryKey);
  });

  return client;
}

export function constructDtoClass(queryKey: QueryKey, data: any): unknown {
  const resultTypeKey = getResultTypeClassKey(queryKey);
  const constructorFunction = getResultTypeFactory(resultTypeKey);

  if (!data || !constructorFunction)
    return data;

  return constructorFunction(data);
}

export function getResultTypeClassKey(queryKey: QueryKey): string {
  if (!Array.isArray(queryKey)) {
    return queryKey as unknown as string;
  }
  if (queryKey.length >= 2) {
    // We concatenate first and second elements, because they uniquely identify the query.
    // All other QueryKey elements are query parameters
    return `${queryKey[0]}___${queryKey[1]}`;
  }

  // We actually should never reach this point :)
  return queryKey.join('___');
}

export function initPersister() {
  




  addResultTypeFactory('DepartmentsControllerClient___findAll', (data: any) => { const result = new Department(); result.init(data); return result; });
  addResultTypeFactory('DepartmentsControllerClient___getHierarchy', (data: any) => { const result = new Department(); result.init(data); return result; });
  addResultTypeFactory('DepartmentsControllerClient___findAllWithUsers', (data: any) => { const result = new Department(); result.init(data); return result; });
  addResultTypeFactory('DepartmentsControllerClient___findOne', (data: any) => { const result = new Department(); result.init(data); return result; });
  addResultTypeFactory('DepartmentsControllerClient___findBySlug', (data: any) => { const result = new Department(); result.init(data); return result; });


  addResultTypeFactory('EventsControllerClient___findAll', (data: any) => { const result = new EventResponseDto(); result.init(data); return result; });
  addResultTypeFactory('EventsControllerClient___findOne', (data: any) => { const result = new EventResponseDto(); result.init(data); return result; });






  addResultTypeFactory('CartsControllerClient___findAll', (data: any) => { const result = new Cart(); result.init(data); return result; });
  addResultTypeFactory('CartsControllerClient___findBySession', (data: any) => { const result = new Cart(); result.init(data); return result; });
  addResultTypeFactory('CartsControllerClient___findOne', (data: any) => { const result = new Cart(); result.init(data); return result; });




  addResultTypeFactory('PaymentsControllerClient___getTransactionsByOrder', (data: any) => { const result = new Transaction(); result.init(data); return result; });
  addResultTypeFactory('PaymentsControllerClient___getTransactionsByOrganization', (data: any) => { const result = new Transaction(); result.init(data); return result; });


  addResultTypeFactory('PluginsControllerClient___findAll', (data: any) => { const result = new PluginResponseDto(); result.init(data); return result; });
  addResultTypeFactory('PluginsControllerClient___findOne', (data: any) => { const result = new PluginResponseDto(); result.init(data); return result; });
  addResultTypeFactory('PluginsControllerClient___findByCategory', (data: any) => { const result = new PluginResponseDto(); result.init(data); return result; });
  addResultTypeFactory('PluginsControllerClient___findByExtensionPoint', (data: any) => { const result = new PluginResponseDto(); result.init(data); return result; });
  addResultTypeFactory('PluginsControllerClient___getInstalledPlugins', (data: any) => { const result = new InstalledPluginDto(); result.init(data); return result; });
  addResultTypeFactory('PluginsControllerClient___getEnabledPlugins', (data: any) => { const result = new InstalledPluginDto(); result.init(data); return result; });
  addResultTypeFactory('PluginsControllerClient___getPaymentPlugins', (data: any) => { const result = new InstalledPluginDto(); result.init(data); return result; });
  addResultTypeFactory('PluginsControllerClient___getPluginsByType', (data: any) => { const result = new InstalledPluginDto(); result.init(data); return result; });








  addResultTypeFactory('AnalyticsControllerClient___getAudienceData', (data: any) => { const result = new AudienceAnalyticsDto(); result.init(data); return result; });
  addResultTypeFactory('AnalyticsControllerClient___getEventAnalytics', (data: any) => { const result = new EventAnalytics(); result.init(data); return result; });
  addResultTypeFactory('AnalyticsControllerClient___getSalesAnalytics', (data: any) => { const result = new SalesAnalytics(); result.init(data); return result; });




}
//-----/PersistorHydrator.File----